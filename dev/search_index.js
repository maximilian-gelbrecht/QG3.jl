var documenterSearchIndex = {"docs":
[{"location":"ref/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [QG3]\nOrder   = [:type, :function]","category":"page"},{"location":"ref/#QG3.AbstractGridType","page":"Reference","title":"QG3.AbstractGridType","text":"AbstractGridType{T, onGPU}\n\nAbstract type for grids. The grids save information about the transform from the spatial to spectral grid, e.g. pre-computed Legendre Polynomials\n\nRequired fields: \n\nGtoSH\nSHtoG\ndμ\ndλ\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.AbstractSHTransform","page":"Reference","title":"QG3.AbstractSHTransform","text":"abstract type AbstractSHTransform{onGPU}\n\nRequired fields for all subtypes: \n\noutputsize\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.AbstractμDerivative","page":"Reference","title":"QG3.AbstractμDerivative","text":"abstract type AbstractμDerivative{onGPU} < AbstractDerivative{onGPU} \n\nRequired fields: \n\nmsinθ: To change between μ and latitude derivative (-sin(colats))\nmsinθ_3d: To change between μ and latitude derivative (-sin(colats))\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.ContinousTimeForcing","page":"Reference","title":"QG3.ContinousTimeForcing","text":"TimeForcing\n\nTime-dependent Forcing\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.Derivative_dλ","page":"Reference","title":"QG3.Derivative_dλ","text":"Derivative_dλ(p::QG3ModelParameters{T}; N_batch::Int=0)\n\nPre-computes Derivatives by longitude. Uses the SH relation, is therefore independ from the grid.\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.GaussianGrid","page":"Reference","title":"QG3.GaussianGrid","text":" GaussianGrid{T, onGPU} <: AbstractGridType{T, onGPU}\n\nStruct for the transforms and derivates of a Gaussian Grid\n\nFields:\n\nGtoSH::GaussianGridtoSHTransform\nSHtoG::GaussianSHtoGridTransform\ndμ::GaussianGrid_dμ\ndλ::Derivative_dλ\nΔ::Laplacian\n∇8::Hyperdiffusion\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.GaussianGrid_dμ","page":"Reference","title":"QG3.GaussianGrid_dμ","text":"GaussianGrid_dμ(p::QG3ModelParameters{T}, N_level::Int=3; N_batch::Int=0)\n\nPre-computes Pseudo-spectral approach to computing derivatives with repsect to μ = sin(lats). Derivatives are called with following the naming scheme: \"Domain1Input\"to\"Domain2Output\"_d\"derivativeby\"\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.GaussianGridtoSHTransform","page":"Reference","title":"QG3.GaussianGridtoSHTransform","text":"GaussianGridtoSHTransform(p::QG3ModelParameters{T}, N_level::Int=3; N_batch::Int=0)\n\nReturns transform struct, that can be used with transform_SH. Transforms Gaussian Grid data to real spherical harmonics coefficients that follow the coefficient logic explained in the main documenation.\n\nAdditional input arguments:\n\nN_level: defines the transform for N_level horizontal levels. Has to be equal to three for the QG3 model itself, but might be different for other applications. \nN_batch: defines the transforms with an additional batch dimension for ML tasks, if N_batch==0 this is omitted\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.Hyperdiffusion","page":"Reference","title":"QG3.Hyperdiffusion","text":"Hyperdiffusion(p::QG3ModelParameters{T}; scale::T=T(1)) where T\n\nInitializes the Hyperdiffusion / horizonatal diffusion operator. \n\nApply it via the (@ref)[∇8] functions.\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.KineticEnergyCallback","page":"Reference","title":"QG3.KineticEnergyCallback","text":"KineticEnergyCallback{T}(m::QG3Model)\n\nInitializes a callback to compute the kinetic energy. Can be called with (u, t, integrator) and therefore used with a SavingCallback.\n\nTo initialize a SavingCallback you can e.g. do\n\nvals = SavedValues(eltype(m), Vector{eltype(m)})\nsol = solve(prob; cb=SavingCallback(KineticEnergyCallback(m), vals))\nvals.saveval \n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.Laplacian","page":"Reference","title":"QG3.Laplacian","text":"Laplacian(p::QG3ModelParameters{T}; init_inverse=false, R::T=T(1), N_batch::Int=0, kwargs...) where T\n\nInitializes the Laplacian in spherical harmonics and if init_inverse==true also its inverse\n\nApply the Laplacian with the functions (@ref)[Δ] and (@ref)[Δ⁻¹]\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.QG3Model","page":"Reference","title":"QG3.QG3Model","text":"QG3Model{T}\n\nHolds all parameter and grid information, plus additional pre-computed fields that save computation time during model integration. All these parameter are seen as constants and not trainable. It should be computed on CPU, if you are on GPU use CUDA.@allowscalar QG3Model(...).\n\nFields\n\np::QG3ModelParameters{T} Parameters of the model\ng::AbstractGridType{T} Grid type with pre-computed plans or Legendre polynomals and co.\nk::AbstractArray{T,2} Array, drag coefficient pre-computed from orography and land-sea mask\nTRcoeffs::AbstractArray{T,3} Array of Temperature relaxation coefficients (2d version)\nTR_matrix Matrix for temperature relaxation (3d version)\ncosϕ::AbstractArray{T,2} cos(latitude) pre computed\nacosϕi::AbstractArray{T,2} inverse of a*cos(latitude) pre computed\nTψq matrix used for transforming stream function to voriticy   q = Tψq * ψ + F\nTqψ`inverse of Tψq   ψ = Tqψ*(q - F)\nf modified coriolis vector used in transforming stream function to vorticity\nf_J3 coriolis contribution to Jacobian at 850hPa\n∂k∂ϕ derivates of drag coefficients, pre computed for Ekman dissipation\n∂k∂μ\n∂k∂λ includes 1/cos^2ϕ (for Ekman dissipiation computation)\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.QG3Model-Tuple{QG3ModelParameters}","page":"Reference","title":"QG3.QG3Model","text":"QG3Model(p::QG3ModelParameters; N_level::Integer=3, kwargs...)\n\nRoutine that pre computes the QG3 Model and returns a QG3Model struct with all precomputed fields except for the forcing.\n\nThe pre-computation is always done on CPU due to scalar indexing being used, if a GPU is avaible the final result is then transferred to the GPU.\n\nIf N_level` is set to values other than three, the pre-computations for the transforms and derivatives are computed with N_level levels, but the full model will not be working! This is just for accessing the transforms and derivatives\n\nAll kwargs are forwarded to grid.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.QG3ModelParameters","page":"Reference","title":"QG3.QG3ModelParameters","text":"QG3ModelParameters{T}\n\nSaves all the parameters of the model, also the units/normalization. \n\nFields\n\nL::Int: number of SH number l, note that 0,...,lmax, so that L is lmax + 1\nM::Int: # maximum number M values, M==2L - 1 / 2l_max + 1\nN_lats::Int\nN_lons::Int\nlats::AbstractArray{T,1}\nθ::AbstractArray{T,1} colatitudes = θ\nμ::AbstractArray{T,1} sin(lats) == cos(colats)\nLS::AbstractArray{T,2} Land see mask, on the same grid as lats and lons\nh::AbstractArray{T,2}` orography, array on the same grid as lats and lons\nR1i::T square inverse of Rossby radius 1 200-500hPa, default 1/(700km)^2\nR2i::T square inverse of Rossby radius 2 500-800hPa, default 1/(450km)^2\nH0::T scaling parameter for topography, default 9000m\nτRi::T inverse of radiative time scale, default 1/(25d)\nτEi::T inverse of drag time scale, default 1/(3d)\ncH::T horizonatal diffusion coefficient\nα1::T drag coefficient 1, default 0.5\nα2::T drag coefficient 2, default 0.5\ngridtype::String either 'gaussian' or 'regular', 'gaussian' leads to all transform being done by somewhat naively implemented transforms, 'regular' uses FastTransforms.jl\ntime_unit::T unit so that t [normalized] = t [d] / time_unit, default = 1 / 4π\ndistance_unit::T, default Earth's radius, so that s [normalized] = s [m] / distance_unit, default = 6.371e6\nψ_unit::T, derived from timeunit and distanceunit, so that ψ [normalized] = ψ [m^2/s] / ψ_unit\nq_unit::T, derived from timeunit and distanceunit\n\nOther constructors\n\nQG3ModelParameters(L::Int, lats::AbstractArray{T,1}, lons::AbstractArray{T,1}, LS::AbstractArray{T,2}, h::AbstractArray{T,2}, R1i::T, R2i::T, H0::T, τRi::T, τEi::T, τHi::T, α1::T, α2::T, a::T, gridtype::String, time_unit::T, distance_unit::T)\n\nDefault arguments for most parameters, so that\n\nQG3ModelParameters(L::Int, lats::AbstractArray{T,1}, lons::AbstractArray{T,1}, LS::AbstractArray{T,2}, h::AbstractArray{T,2})\n\nworks as well.\n\nNormalization/units of the model\n\nThe model is normalized in (natural) units of the system. \n\nDistance: The Earth's radius is set to 1 (and thus all units containing distance are scaled with the actual radius of the Earth)\nVorticity: Earth's angular speed is approximately 2π/d, here Earth's angular speed is set 2Ω = 1, so that the planetery vorticity component of the Jacobian is just ∂ψ/∂λ. Therefore: Ω = 1/2, it follows 2*2π [1/d] = 1 [Ωnormalized], therefore Ωnormalized = 4π/d. \nTime: From the vorticity unit, follows the time unit is [d/4π] = [dnormalized]. Hence, time in days must be devided by 4π to get the natural time unit, or [dnormalized] = 4π [d]\nboth ψ and q thus need to expressed in these units too, this can be done using the ψ_unit and q_unit    \n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.SHtoGaussianGridTransform","page":"Reference","title":"QG3.SHtoGaussianGridTransform","text":"SHtoGaussianGridTransform(p::QG3ModelParameters{T}, N_level::Int=3; N_batch::Int=0)\n\nReturns transform struct, that can be used with transform_grid. Transforms real spherical harmonics coefficients to Gaussian grid data, follows the coefficient logic explained in the main documenation.\n\nAdditional input arguments:\n\nN_level: defines the transform for N_level horizontal levels. Has to be equal to three for the QG3 model itself, but might be different for other applications. \nN_batch: defines the transforms with an additional batch dimension for ML tasks, if N_batch==0 this is omitted\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.D-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}, QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}} where T","page":"Reference","title":"QG3.D","text":"D(ψ::AbstractArray{T,3}, q::AbstractArray{T,3}, m::QG3Model{T})\n\nComputes the dissipiation of all levels, 850hPa has additional Ekman dissipation.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.EK-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}} where T<:Number","page":"Reference","title":"QG3.EK","text":"EK(ψ::AbstractArray{T,2}, m::QG3Model{T})\n\nComputes the Ekman dissipation with: \n\nEK = ∇(k∇ψ) = (∇k ∇ψ) + k Δψ  EK = 1/a^2cos^2ϕ ∂k/∂λ ∂ψ/∂λ + 1/a^2 ∂k/∂ϕ ∂ψ/∂ϕ + k Δψ   (a==1)\n\nm.∂k∂λ  includes 1/cos^2ϕ\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.H-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}} where T<:Number","page":"Reference","title":"QG3.H","text":"H(qprime::AbstractArray{T,3}, i::Int, m::QG3Model{T})\n\nComputes the Horizontal diffusion at level i, q' is anomolous pv (without coriolis) 2D Fields m.cH∇8 = m.p.cH * m.∇8\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.H-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}} where T","page":"Reference","title":"QG3.H","text":"H(qprime::AbstractArray{T,3}, m::QG3Model{T})\n\nComputes the horizontal diffusion, q' is anomolous pv (without coriolis) 3D Fields\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.J-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}, QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}} where T","page":"Reference","title":"QG3.J","text":"J(ψ::AbstractArray{T,3}, q::AbstractArray{T,3}, m::QG3Model{T})\n\nComputes the Jacobian for the QG3 model in 3D Field formulation (e.g. for GPU). Takes as an imput the streamfunction ψ and the potential vorticity q' without the coriolis contribution. Adds the contribution of the Coriolis force and orography at the 850hPa level that is prescribed in the MM QG3 Model. \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.J-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, QG3.AbstractGridType{T}}} where T<:Number","page":"Reference","title":"QG3.J","text":"J(ψ::AbstractArray{T,2}, q::AbstractArray{T,2}, g::AbstractGridType{T})\n\nCompute the Jacobian determinant from ψ and q in μ,λ coordinates, J = ∂ψ/∂x ∂q/∂y - ∂ψ/∂y ∂q/∂x = 1/a^2cosϕ ( - ∂ψ/∂λ ∂q/∂ϕ + ∂ψ/∂ϕ ∂q/∂λ) =  1/a^2 (- ∂ψ/∂λ ∂q/∂μ + ∂ψ/∂μ ∂q/∂λ)\n\nThe last term ∂ψ/∂λ accounts for the planetery vorticity, actually it is 2Ω ∂ψ/∂λ, but 2Ω == 1, (write q = q' + 2Ωμ to proof it)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.J3-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}} where T<:Number","page":"Reference","title":"QG3.J3","text":"J3(ψ::AbstractArray{T,2}, q::AbstractArray{T,2}, m::QG3Model{T})\n\nFor the Jacobian at 850hPa, q = q' + f(1+h/H0) = q' + f + f*h/H0, so that the thrid term has to be added.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.J_F-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, QG3.AbstractGridType{T}}} where {T, N}","page":"Reference","title":"QG3.J_F","text":"J_F(ψ::AbstractArray{T,N}, q::AbstractArray{T,N}, g::AbstractGridType{T})\n\nCompute the Jacobian determinant from ψ and q in μ,λ coordinates without the planetary vorticity, as used in computing the eddy/transient forcing\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.J_F_Grid-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, QG3.AbstractGridType{T}}} where {T, N}","page":"Reference","title":"QG3.J_F_Grid","text":"J_F_Grid(ψ::AbstractArray{T,N}, q::AbstractArray{T,N}, g::AbstractGridType{T})\n\nComputes the Jacobian (without the planetary voriticity), input SPH, output Grid space \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.Jprime-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}, QG3.AbstractGridType{T}}} where T","page":"Reference","title":"QG3.Jprime","text":"Jprime(ψ::AbstractArray{T,3}, q::AbstractArray{T,3}, g::AbstractGridType{T})\n\nComputes the Jacobian (∂ψ/∂μ ∂q/∂λ - ∂ψ/∂λ ∂q/∂μ). Directly computes the derivatives of the two inputs ψ and q and doesn't account for any additional contribution (e.g. from the Coriolis force).\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.QG3MM_adv-Tuple{Any, Any, Any}","page":"Reference","title":"QG3.QG3MM_adv","text":"QG3MM_adv(q, p, t)\n\nJust the Advection\n\ndq = - J(ψ,q)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.QG3MM_base-Tuple{Any, Any, Any}","page":"Reference","title":"QG3.QG3MM_base","text":"QG3MM_base(q, p, t)\n\nBase model used in the MM paper, with symmetrization around the equator\n\ndq = - J(ψ,q) - D(ψ,q) + S\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.QG3MM_gpu-Tuple{Any, Any, Any}","page":"Reference","title":"QG3.QG3MM_gpu","text":"QG3MM_gpu(q, p, t)\n\nBase model used in the MM paper dq = - J(ψ,q) - D(ψ,q) + S\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SH_zero_mask","page":"Reference","title":"QG3.SH_zero_mask","text":"SH_zero_mask(p::QG3.QG3ModelParameters, size_tup=nothing)\n\nReturns a mask that zeroes out all spurious elements of the SH coefficients + the (0,0) element which is also set zero\n\n\n\n\n\n","category":"function"},{"location":"ref/#QG3.SHtoGrid_dθ-Union{Tuple{T}, Tuple{Any, QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}} where T","page":"Reference","title":"QG3.SHtoGrid_dθ","text":"derivative of input after θ (azimutal angle/colatitude) in SH, uses pre computed SH evaluations (dependend on the grid type)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoGrid_dλ-Tuple{Any, Any}","page":"Reference","title":"QG3.SHtoGrid_dλ","text":"SHtoGrid_dλ(ψ, m::QG3Model{T})\nSHtoGrid_dλ(ψ, m::AbstractGridType{T})\n\nDerivative of input after φ (polar angle) or λ (longtitude) in SH to Grid\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoGrid_dμ-Union{Tuple{T}, Tuple{Any, QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}} where T","page":"Reference","title":"QG3.SHtoGrid_dμ","text":"SHtoGrid_dμ(ψ, m::QG3Model{T}) \nSHtoGrid_dμ(ψ, g::AbstractGridType) \nSHtoGrid_dμ(ψ, d::GaussianGrid_dμ)\n\nDerivative of input after μ = sinϕ in SH, uses pre computed SH evaluations\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoGrid_dφ-Union{Tuple{T}, Tuple{Any, QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}} where T","page":"Reference","title":"QG3.SHtoGrid_dφ","text":"SHtoGrid_dφ(ψ, m::QG3Model{T})\nSHtoGrid_dφ(ψ, m::AbstractGridType{T})\nSHtoGrid_dφ(ψ, dλ::Derivative_dλ, sh2g::AbstractSHtoGridTransform)\n\nDerivative of input after φ (polar angle) or λ (longtitude) in SH to Grid\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoGrid_dϕ-Tuple{Any, Any}","page":"Reference","title":"QG3.SHtoGrid_dϕ","text":"SHtoGrid_dϕ(ψ, m)\n\nDerivative of input after ϕ - latitude in SH, uses pre computed SH evaluations\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoSH_dλ-Tuple{Any, Any}","page":"Reference","title":"QG3.SHtoSH_dλ","text":"SHtoSH_dλ(ψ, m::QG3Model{T})\nSHtoSH_dλ(ψ, g::GaussianGrid)\n\nDerivative of input after φ (polar angle/longtitude) in SH, output in SH\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoSH_dφ-Union{Tuple{T}, Tuple{Any, QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}} where T","page":"Reference","title":"QG3.SHtoSH_dφ","text":"SHtoSH_dφ(ψ, m::QG3Model{T})\nSHtoSH_dφ(ψ, g::GaussianGrid) \nSHtoSH_dφ(ψ, g::Derivative_dλ)\n\nDerivative of input after φ (polar angle/longtitude) in SH, output in SH\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.TR-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}} where T","page":"Reference","title":"QG3.TR","text":"TR(ψ::AbstractArray{T,3}, m::QG3Model{T})\n\nComputes the temperature relaxation of all levels\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.TR-Union{Tuple{T}, Tuple{QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}, Any, Any, T}} where T<:Number","page":"Reference","title":"QG3.TR","text":"TR(m::QG3Model{T}, ψ1, ψ2, Ri::T)\n\nComputes the Temperature relaxation between layers with streamfunction ψ1 and ψ2.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.angular_power_spectrum-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}}} where T","page":"Reference","title":"QG3.angular_power_spectrum","text":"angular_power_spectrum(A::AbstractArray{T,2}, p::QG3ModelParameters{T})\n\nComputes the angular power spectrum of a matrix in the QG3.jl SPH convention. \n\nUsually ploted in logartihmic plots, e.g. with plot(angular_power_spectrum(A, p), yscale=:log10) )\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.change_msign!-Tuple{Any}","page":"Reference","title":"QG3.change_msign!","text":"change_msign!(A)\n\nChange the sign of the m in SH (FastTranforms.jl convention of storing them). This version swaps the columns inplace\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.change_msign-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}}} where T","page":"Reference","title":"QG3.change_msign","text":"change_msign(A)\n\nChange the sign of the m in SH. This version returns a view\n\nthere is currently a bug or at least missing feature in Zygote, the AD library, that stops views from always working flawlessly when a view is mixed with prior indexing of an array. We need a view for the derivative after φ to change the sign of m, so here is a differentiable variant of the SHtoSH_dφ function for the 2d field\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_GaussWeights-Union{Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}}, Tuple{T}, Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}, Any}} where T<:Number","page":"Reference","title":"QG3.compute_GaussWeights","text":"Pre-computes gaussian weights for Legendre Transform, also checks if we really have the correct gaussian latitudes\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_P-Union{Tuple{T}, Tuple{Integer, Integer, AbstractVector{T}}} where T<:Number","page":"Reference","title":"QG3.compute_P","text":"Pre-compute ass. Legendre Polynomials and dP/dx (derivative of ass. Legendre Polynomial) at the grid points and also the remainder of the Spherical Harmonics at the grid points using GSL\n\nm values are stored 0,-1,1,-2,2,-3,3,... (on CPU) m values are stored 0,1,2,3,4,5,6,7, ...l_max, 0 (nothing),-1, -2, -3, (on GPU)  (the second 0 is the Imanigary part / sin part of the fourier transform which is always identical to zero, it is kept here to have equal matrix sizes)\n\nso far only |m| is used, as I assume real SPH.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_S_Roads-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}} where T<:Number","page":"Reference","title":"QG3.compute_S_Roads","text":"compute_S_Roads(data::AbstractArray{T,4}, m::QG3Model{T}; datasource=\"ψ\")\n\nPre-compute Forcing S data level,X,Y,t\n\nCompute the forcing according to Roads, this is outlined in the MM and Corti paper as well.\n\nThis uses an unfiltered version, in the Corti paper there is a filter. Maybe implement it as well\n\ndata, input data\nm, QG3Model Parameters and pre-computed fields\nkwargs\ndatasource, either 'qprime' (anomalous potential vorticity) or 'sf' (streamfunction)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_S_t_corti","page":"Reference","title":"QG3.compute_S_t_corti","text":"Pre-compute time-dependent Forcing S data level,X,Y,t\n\nLike in the Corti paper for the seasonal run this interpolates between two extremal forcings.\n\nNt_year: how many days does a year have / period length of the sinus\n\n\n\n\n\n","category":"function"},{"location":"ref/#QG3.compute_TR-Union{Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_TR","text":"Pre-compute array of temperature relaxation coefficients.\n\n(l=0, m=0)-coefficient is assigned zero. This results in this expansion coefficient beeing constant in the whole model.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_TR_matrix-Union{Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_TR_matrix","text":"Pre-compute matrices involved in the temperature relaxation in matrix form (for GPU / 3d fields)\n\nTR = TRMatrix * ψ  ∀ l ∈ [0,lmax]\n\nFor l=0 the matrix is set to be zero\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_acosϕi-Tuple{QG3ModelParameters}","page":"Reference","title":"QG3.compute_acosϕi","text":"Pre-compute cos(ϕ)^-1 (latitude matrix)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_batched_TR_matrix-Union{Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_batched_TR_matrix","text":"compute_batched_TR_matrix\n\nprepares the TR = TRMatrix * ψ  ∀ l ∈ [0,lmax] matrix for batched multiply\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_batched_ψq_transform_matrices-Union{Tuple{T}, Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}, QG3.Laplacian{T, M, A1, A2} where {M<:AbstractMatrix{T}, A1<:AbstractArray{T, 3}, A2<:AbstractArray{T, 3}}}} where T<:Number","page":"Reference","title":"QG3.compute_batched_ψq_transform_matrices","text":"compute_batched_ψq_transform_matrices\n\nprepares the transform from q to ψ and back for a batched matrix vector multiply, see also (@ref)[compute_ψq_transform_matrices]\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_coriolis_vector_grid-Union{Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_coriolis_vector_grid","text":"Pre-compute a matrix with with the Coriolis factor\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_cosϕ-Union{Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}}, Tuple{T}} where T","page":"Reference","title":"QG3.compute_cosϕ","text":"Pre-compute cos(ϕ) (latitude) matrix\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_f_J3-Union{Tuple{T}, Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}, AbstractArray{T, 3}}} where T<:Number","page":"Reference","title":"QG3.compute_f_J3","text":"Pre-compute the additional contribution of the Coriolis force to the 850hPa Jacobian component in GPU ready format, for the Jacobian at 850hPa, q = q' + f(1+h/H0) = q' + f + f*h/H0, so that the thrid term has to be added.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_k-Union{Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_k","text":"Pre-compute drag coefficient k in real grid space, double check with values from paper\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_Δ-Union{Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_Δ","text":"Pre-compute the Laplacian in Spherical Harmonics, follows the matrix convention of FastTransforms.jl\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_Δ⁻¹-Union{Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_Δ⁻¹","text":"Pre-compute the inverse Laplacian in Spherical Harmonics, follows the matrix convention of FastTransforms.jl\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_ψq_transform_matrices-Union{Tuple{T}, Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}, QG3.Laplacian{T, M, A1, A2} where {M<:AbstractMatrix{T}, A1<:AbstractArray{T, 3}, A2<:AbstractArray{T, 3}}}} where T<:Number","page":"Reference","title":"QG3.compute_ψq_transform_matrices","text":"Pre-compute matrices involved in transforming vorticity to streamfunction and back\n\nq = Tψq * ψ + f ψ = Tqψ * (q - f) = Tψq^(-1) * (q - f)\n\nFor l=0 the matrix is singular. In the fortran code they set q to something which for me does not make sense. Here Tψq(l=0) is just 1, so that transforming back and forth recovers the correct ψ. This makes sense in my eyes because q is only ever used for its spatial derivatives, all of which are 0 for l=0.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_∇8-Tuple{QG3ModelParameters}","page":"Reference","title":"QG3.compute_∇8","text":"\" Pre-compute the 8-th derivative in Spherical Harmonics\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.gpuoff-Tuple{}","page":"Reference","title":"QG3.gpuoff","text":"gpuoff()\n\nManually toggle GPU use off\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.gpuon-Tuple{}","page":"Reference","title":"QG3.gpuon","text":"gpuon()\n\nManually toggle GPU use on (if available)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.grid-Union{Tuple{T}, Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}, String}, Tuple{QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}, String, Int64}} where T<:Number","page":"Reference","title":"QG3.grid","text":"grid(p::QG3ModelParameters{T}, gridtype::String, N_level::Int=3; N_batch::Int=0, kwargs...)\n\nConvience constructor for the AbstractGridType based on the parameters set in p.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.hours-Tuple{Any, QG3Model}","page":"Reference","title":"QG3.hours","text":"hours(x, m::QG3Model)\n\nConvert from model time units to hours\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.isongpu-Union{Tuple{QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}, Tuple{T}} where T","page":"Reference","title":"QG3.isongpu","text":"isongpu(m::QG3Model{T})\n\nDetermines if the model was pre-computed to be used on GPU.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.kinetic_energy-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}} where T","page":"Reference","title":"QG3.kinetic_energy","text":"kinetic_energy(ψ::AbstractArray{T,3}, m::QG3Model{T}) where T\n\nComputes the kinetic energy per layer\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.lMatrix-Tuple{Integer, Integer}","page":"Reference","title":"QG3.lMatrix","text":"lMatrix(L, M; GPU=nothing)\n\nReturn l-Matrix of SH coefficients in convention of FastTransforms.jl. \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.level_index-Tuple{Any, Any}","page":"Reference","title":"QG3.level_index","text":"level_index(strings,lvls)\n\nHelper function for indexing netcdf files with many levels.\n\nstring, array with name of levels to be selected\nlvls, array with all levels\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.load_precomputed_data-Tuple{}","page":"Reference","title":"QG3.load_precomputed_data","text":"load_precomputed_data(GPU=false)\n\nLoads the precomputed data that is saved in the package. It is computed from ERA5 T21 u/v data. Returns in order\n\nS, qg3ppars, ψ_0, q_0\nForcing, Parameters, Streamfunction initial conditions, vorticity initial conditions\n\nIf GPU==true returns those in GPU SPH order as CuArrays, otherwise uses CPU SPH order. \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.mMatrix-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"Reference","title":"QG3.mMatrix","text":"mMatrix(L::Integer, M::Integer)\n\nPre-compute a matrix with (m) values of the SH matrix format of FastTransforms.jl, used for zonal derivative\n\nKwarg 'GPU', if given, overrides the automatic detection of wheather or not a GPU is avaible. \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.make3d-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.make3d","text":"make3d(A::AbstractArray{T,2})\n\nrepeats an array three times to turn it into (3 x size(A,1) x size(A,2)), for the fully matrix version of model.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.qprimetoψ-Union{Tuple{T}, Tuple{QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}, AbstractArray{T, 3}}} where T","page":"Reference","title":"QG3.qprimetoψ","text":"qprimetoψ(p::QG3Model{T}, q::AbstractArray{T,3})\n\nConvert the anomalous potential vorticity q' to streamfunction ψ. \n\nThis version is slightly slower than the old one (as it not aware of the matrix being half full of zeroes), but it is non-mutating which makes it suitable for the automatic differentation.\n\nIt replaces the double loop over the coefficient matrix with a batched vector multiply. The advantage of that is that it is optimised for GPU, so it might actually be faster on the GPU than doing a manual loop.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.qprimetoψ-Union{Tuple{T}, Tuple{QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}, AbstractArray{T, 4}}} where T","page":"Reference","title":"QG3.qprimetoψ","text":"qprimetoψ(p::QG3Model{T}, q::AbstractArray{T,4})\n\nConvert the anomalous potential vorticity q' to streamfunction ψ. \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.qtoψ-Union{Tuple{T}, Tuple{QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}, AbstractArray{T, 3}}} where T<:Number","page":"Reference","title":"QG3.qtoψ","text":"qtoψ(p::QG3Model{T}, q::AbstractArray{T,3})\n\nConvert the potential vorticity q to streamfunction ψ. See also qprimetoψ. \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.reorder_SH_cpu-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3ModelParameters}} where T","page":"Reference","title":"QG3.reorder_SH_cpu","text":"reorder_SH_cpu(A::AbstractArray{T,3},p::QG3ModelParameters)\n\nReorders the SH coefficient so that computations on CPU are more efficient, inverse of reorder_SH_gpu\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.reorder_SH_cpu-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, QG3ModelParameters}} where T","page":"Reference","title":"QG3.reorder_SH_cpu","text":"reorder_SH_cpu(A::AbstractArray{T,4},p::QG3ModelParameters)\n\nReorders the SH coefficient so that computations on CPU are more efficient, inverse of reorder_SH_gpu\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.reorder_SH_cpu-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3ModelParameters}} where T","page":"Reference","title":"QG3.reorder_SH_cpu","text":"reorder_SH_cpu(A::AbstractArray{T,2},p::QG3ModelParameters)\n\nReorders the SH coefficient so that computations on CPU are more efficient, inverse of reorder_SH_gpu\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.reorder_SH_gpu-Union{Tuple{T}, Tuple{S}, Tuple{AbstractMatrix{S}, QG3ModelParameters{T, I, A, M} where {I<:Int64, A<:AbstractVector{T}, M<:AbstractMatrix{T}}}} where {S, T}","page":"Reference","title":"QG3.reorder_SH_gpu","text":"Reorders the SH coefficient so that computations on GPU are more efficient, it also includes the truncation as the SH array has size Nlat x Nlon, however all entries outside of L x M are zeroes.\n\nOriginal order (FastTransforms.jl) columns by m : 0, -1, 1, -2, -2, ....\n\nNew order columns by m: 0, 1, 2, ... l_max, 0 (nothing), -1, -2, ..\n\n2d input assumes L x M matrix, (all fields in SH), also enlarges the matrix to include truncation (additional elements are zero) to Nlat x Nlons 3d input assumes Nlat (or 3) x L x M matrix (e.g. precomputed legendre polynomials), also enlarges the matrix to include truncation (additional elements are zero) to Nlat (or 3) x Nlats x Nlons\n\nIncase CUDA is not used, it just return the input.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.sph_zero_spurious_modes!-Tuple{AbstractMatrix}","page":"Reference","title":"QG3.sph_zero_spurious_modes!","text":"Sets the unphysical numbers zero (usually only needed for FastTransforms.jl)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.transform_SH","page":"Reference","title":"QG3.transform_SH","text":"transform_SH(data::AbstractArray{T,N}, t::GaussianGridtoSHTransform) \ntransform_SH(data::AbstractArray, m::QG3Model)\n\nTransforms data into the spherical harmonics domain. The coefficents are ordered in a matrix in coloumns of the m value. On CPU the convention of FastTransform.jl is used (0, -1, 1, -2, 2, ...), on GPU the convention (0, 1, 2, 3, ...., (nothing, -1, -2, -3, ...)). Watch out, in future proabaly this might be standardized. \n\n\n\n\n\n","category":"function"},{"location":"ref/#QG3.transform_grid","page":"Reference","title":"QG3.transform_grid","text":"transform_grid(data::AbstractArray{T,N}, t::SHtoGaussianGridTransform)\n\nTransforms data from the spherical harmonics domain to a Gaussian Grid. The coefficents are ordered in a matrix in coloumns of the m value. On CPU the convention of FastTransform.jl is used (0, -1, 1, -2, 2, ...), on GPU the convention (0, 1, 2, 3, ...., (nothing, -1, -2, -3, ...)). Watch out, in future proabaly this might be standardized. \n\ntransform_grid(data, m::QG3Model; varname=\"ψ\")\n\nIf varname ∈ [\"pv\",\"q\",\"vorticity\"] the [1,1] element is set to zero first, as this element is set to the streamfunction-[1,1] usually in the ψtoq routines.\n\n\n\n\n\n","category":"function"},{"location":"ref/#QG3.zeros_Grid-Union{Tuple{QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}, Tuple{T}} where T","page":"Reference","title":"QG3.zeros_Grid","text":"zeros_Grid(p::QG3Model{T})\n\nReturns a zero array in the dimensions of the grid. \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.zeros_SH-Union{Tuple{QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}, Tuple{T}} where T","page":"Reference","title":"QG3.zeros_SH","text":"zeros_SH(p::QG3Model{T})\n\nReturns a zero array in the dimensions of the SH. \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.Δ-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, QG3.Laplacian{T, M, A1, A2} where {M<:AbstractMatrix{T}, A1<:AbstractArray{T, 3}, A2<:AbstractArray{T, 3}}}} where T","page":"Reference","title":"QG3.Δ","text":"Δ(ψ::AbstractArray, L::Laplacian{T})\nΔ(ψ::AbstractArray, m::QG3Model{T})\n\nApply the Laplacian. Also serves to convert regular vorticity (not the quasigeostrophic one) to streamfunction) \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.Δ⁻¹-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, QG3.Laplacian{T, M, A1, A2} where {M<:AbstractMatrix{T}, A1<:AbstractArray{T, 3}, A2<:AbstractArray{T, 3}}}} where T","page":"Reference","title":"QG3.Δ⁻¹","text":"Δ⁻¹(ψ::AbstractArray, m::QG3Model{T})\n\nApply the inverse Laplacian. Also serves to convert the streamfunction to regular vorticity \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.ψtoq-Union{Tuple{T}, Tuple{QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}, AbstractArray{T, 3}}} where T<:Number","page":"Reference","title":"QG3.ψtoq","text":"ψtoq(p::QG3Model{T}, ψ::AbstractArray{T,3})\n\nConvert the streamfunction ψ to the potential vorticity. See also ψtoqprime.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.ψtoqprime-Union{Tuple{T}, Tuple{QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}, AbstractArray{T, 3}}} where T","page":"Reference","title":"QG3.ψtoqprime","text":"ψtoqprime(p::QG3Model{T}, ψ::AbstractArray{T,3})\n\nConvert the streamfunction ψ to (anomlous) potential vorticity q' in spherical harmonics basis. See also ψtoq.\n\nThis version is slightly slower than the old one on CPU (as it not aware of the matrix being half full of zeroes), but it is non-mutating which makes it suitable for the automatic differentation.\n\nIt replaces the double loop over the coefficient matrix with a batched vector multiply. The advantage other besides it being non-mutating is that it is optimised for GPU, so it might actually be faster on the GPU than doing a manual loop.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.ψtoqprime-Union{Tuple{T}, Tuple{QG3Model{T, P, G, M, A} where {P<:QG3ModelParameters, G<:QG3.AbstractGridType, M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}, AbstractArray{T, 4}}} where T","page":"Reference","title":"QG3.ψtoqprime","text":"ψtoqprime(p::QG3Model{T}, ψ::AbstractArray{T,4})\n\nConvert the anomalous potential vorticity q' to streamfunction ψ. \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.∇8-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3.Hyperdiffusion{T, M, A} where {M<:AbstractMatrix{T}, A<:AbstractArray{T, 3}}}} where T","page":"Reference","title":"QG3.∇8","text":"∇8(q::AbstractArray{T,N}, H::Hyperdiffusion{T})\n\nApply the hyperdiffusion to the input\n\n\n\n\n\n","category":"method"},{"location":"#QG3.jl","page":"Home","title":"QG3.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a Julia implementation of the Marshall, Molteni Quasigeostrophic Atmsopheric Model in three layers. It runs on CPU or CUDA GPUs and is differentiable via Zygote.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The model is solved with a pseudo-spectral approach on a Gaussian grid with approatiate spherical harmonics transforms defined. Example scripts are provided in the examples folder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Install e.g. via ]add https://github.com/maximilian-gelbrecht/QG3.jl.git and test the installation with ]test QG3","category":"page"},{"location":"","page":"Home","title":"Home","text":"The repository includes pre-computed forcing and initial conditions on a T21 to run the model but no proper dataset to compute re-compute those in order to save space. The example folder also includes the necessary scripts to pre-copmute those for other grids and datasets. ","category":"page"},{"location":"#The-Model","page":"Home","title":"The Model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Details about the model can be read up in \"Towards a Dynamical Understanding of Planetary-Scale Flow Regimes\", Marshall, Molteni, Journal of Atmsopheric Sciences, 1992.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Its governing equation for the quasigeostrophic vorticity q_i in three equipressure levels (200, 500, 800 hPa) are given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"dotq_i = -J(psi_i q_i) - D(psi_i q_i) + S \nvecq = T_psi q vecpsi","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the voriticy q and streamfunction psi are related by a linear operator (comprising the Laplacian and temperature relaxation), J is the Jacobian / advection term, D the dissipation and S a forcing computed from data.","category":"page"},{"location":"#Solvers","page":"Home","title":"Solvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This packages includes all function necessary to define the governing equation of the QG3 Model. It does however, not include the differential equations solvers, for those we rely on DifferentialEquations.jl, i.e. OrdinaryDiffEq.jl. In the following, we will therefore briefly talk about how to define the right hand side necessary to define for those solvers, before going into a little more detail on the transforms and derivatives used throughout the model. ","category":"page"},{"location":"#Initialize-a-model","page":"Home","title":"Initialize a model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The model parameter are hold as QG3ModelParameters: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"QG3ModelParameters","category":"page"},{"location":"#QG3.QG3ModelParameters-index","page":"Home","title":"QG3.QG3ModelParameters","text":"QG3ModelParameters{T}\n\nSaves all the parameters of the model, also the units/normalization. \n\nFields\n\nL::Int: number of SH number l, note that 0,...,lmax, so that L is lmax + 1\nM::Int: # maximum number M values, M==2L - 1 / 2l_max + 1\nN_lats::Int\nN_lons::Int\nlats::AbstractArray{T,1}\nθ::AbstractArray{T,1} colatitudes = θ\nμ::AbstractArray{T,1} sin(lats) == cos(colats)\nLS::AbstractArray{T,2} Land see mask, on the same grid as lats and lons\nh::AbstractArray{T,2}` orography, array on the same grid as lats and lons\nR1i::T square inverse of Rossby radius 1 200-500hPa, default 1/(700km)^2\nR2i::T square inverse of Rossby radius 2 500-800hPa, default 1/(450km)^2\nH0::T scaling parameter for topography, default 9000m\nτRi::T inverse of radiative time scale, default 1/(25d)\nτEi::T inverse of drag time scale, default 1/(3d)\ncH::T horizonatal diffusion coefficient\nα1::T drag coefficient 1, default 0.5\nα2::T drag coefficient 2, default 0.5\ngridtype::String either 'gaussian' or 'regular', 'gaussian' leads to all transform being done by somewhat naively implemented transforms, 'regular' uses FastTransforms.jl\ntime_unit::T unit so that t [normalized] = t [d] / time_unit, default = 1 / 4π\ndistance_unit::T, default Earth's radius, so that s [normalized] = s [m] / distance_unit, default = 6.371e6\nψ_unit::T, derived from timeunit and distanceunit, so that ψ [normalized] = ψ [m^2/s] / ψ_unit\nq_unit::T, derived from timeunit and distanceunit\n\nOther constructors\n\nQG3ModelParameters(L::Int, lats::AbstractArray{T,1}, lons::AbstractArray{T,1}, LS::AbstractArray{T,2}, h::AbstractArray{T,2}, R1i::T, R2i::T, H0::T, τRi::T, τEi::T, τHi::T, α1::T, α2::T, a::T, gridtype::String, time_unit::T, distance_unit::T)\n\nDefault arguments for most parameters, so that\n\nQG3ModelParameters(L::Int, lats::AbstractArray{T,1}, lons::AbstractArray{T,1}, LS::AbstractArray{T,2}, h::AbstractArray{T,2})\n\nworks as well.\n\nNormalization/units of the model\n\nThe model is normalized in (natural) units of the system. \n\nDistance: The Earth's radius is set to 1 (and thus all units containing distance are scaled with the actual radius of the Earth)\nVorticity: Earth's angular speed is approximately 2π/d, here Earth's angular speed is set 2Ω = 1, so that the planetery vorticity component of the Jacobian is just ∂ψ/∂λ. Therefore: Ω = 1/2, it follows 2*2π [1/d] = 1 [Ωnormalized], therefore Ωnormalized = 4π/d. \nTime: From the vorticity unit, follows the time unit is [d/4π] = [dnormalized]. Hence, time in days must be devided by 4π to get the natural time unit, or [dnormalized] = 4π [d]\nboth ψ and q thus need to expressed in these units too, this can be done using the ψ_unit and q_unit    \n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"For convenience, a pre-computed setup with forcing S, parameters qg3_pars and initial conditions ψ_0, q_0 can be loaded via ","category":"page"},{"location":"","page":"Home","title":"Home","text":"S, qg3_pars, ψ_0, q_0 = QG3.load_precomputed_data(GPU=false)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, the pre-compute.jl script in the examples folder demonstrates how to compute those from other datasets and for other resolutions. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the model can be pre-computed with the help of QG3Model","category":"page"},{"location":"","page":"Home","title":"Home","text":"qg3 = QG3Model(qg3_pars)","category":"page"},{"location":"","page":"Home","title":"Home","text":"or on GPU ","category":"page"},{"location":"","page":"Home","title":"Home","text":"qg3 = CUDA.@allowscalar QG3Model(qg3_pars) # on GPU the pre-computation need scalar indexing","category":"page"},{"location":"","page":"Home","title":"Home","text":"These struct also hold the grid information qg3.g that comprises all transforms and derivatives. ","category":"page"},{"location":"#GPU-and-CPU","page":"Home","title":"GPU and CPU","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently there are two different implementations, one that is optimised for CPU (the \"2D version\") and one that is optimised for GPU (the \"3D version\"). The GPU version can also run on CPU but not the other way around.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The GPU is automatically detected. If you wish to run the model on CPU on a computer that does have a CUDA capable GPU, then you can turn it of with QG3.gpuoff() before model pre-computation. ","category":"page"},{"location":"#GPU-Version","page":"Home","title":"GPU Version","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The GPU version is fully vectorized, without scalar indexing. All needed functions work on the 3d (level, lat, lon) / (level, il, m) field. The full problem definition thus is just simply","category":"page"},{"location":"","page":"Home","title":"Home","text":"function QG3MM_gpu(q, m, t)\n    p, S = m # parameters, forcing vector\n\n    ψ = qprimetoψ(p, q)\n    return - J(ψ, q, p) - D(ψ, q, p) + S\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This right hand side calls the transform from potential vorticity to the streamfunction qprimetoψ, the advection operator J, the dissipation operator D and the pre-computed forcing S. ","category":"page"},{"location":"#CPU-Version","page":"Home","title":"CPU Version","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The CPU version works on 2d fields (lat, lon) / (il, m), on CPUs this is currently a little faster than using the GPU/3D version on CPU. In other words: the GPU version could probably still be optimized further. The problem definition follows as","category":"page"},{"location":"","page":"Home","title":"Home","text":"function QG3MM_base(q, m, t)\n    p, S = m # parameters, forcing vector\n\n    ψ = qprimetoψ(p, q)\n    return cat(\n    reshape(- J(ψ[1,:,:], q[1,:,:], p) .- D1(ψ, q, p) .+ S[1,:,:], (1, p.p.L, p.p.M)),\n    reshape(- J(ψ[2,:,:], q[2,:,:], p) .- D2(ψ, q, p) .+ S[2,:,:], (1, p.p.L, p.p.M)),\n    reshape(- J3(ψ[3,:,:], q[3,:,:], p) .- D3(ψ, q, p) .+ S[3,:,:], (1, p.p.L, p.p.M)),\n    dims=1)\nend","category":"page"},{"location":"#Model-Units","page":"Home","title":"Model Units","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This implemenation uses a unit system, so that the Earth's radius and angular velocity equals","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nR = 1 \n2Omega = 1\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"from these follow the units for all variables. The parameter struct holds those as qg3_pars.time_unit, qg3_pars.distance_unit, qg3_pars.ψ_unit and qg3_pars.q_unit. ","category":"page"},{"location":"#Transforms","page":"Home","title":"Transforms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Throughout the model real spherical harmonics are used. The transform is implemented with a FFT and a Gauss-Legendre transform that is solved by pre-computing the associated Legendre polynomials and then executing the appropiate matrix multiplication for the transform. This ensures both differentiability and GPU compatability of the transforms. Gradients of the spherical harmonics transforms are checked against finite difference differentiation in the tests.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Transforms are called with transform_SH and transform_grid, e.g. as in the following: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"ψ_0_grid = transform_grid(ψ_0, qg3)\nψ_0_SH = transform_SH(ψ_0_grid, qg3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"SHs coefficients on CPU are handled in the matrix convention that FastTransforms.jl uses: columns by m-value: 0, -1, 1, -2, 2, ..., rows l in ascending order. This was implemented initially during development to ensure compatability with FastTransforms.jl, unfortunately however, using FastTransforms.jl isn't currently working (yet) due to aliasing problems. On GPU, we store the coefficients differently to avoid additional operations to reorder all coefficents that would be needed otherwise with the CUFFT routines. Therefore the coefficient matrix convention is different on GPU, where the columns are ordered 0, 1, 2, .... l_max, 0, -1, -2, -3, .. . ","category":"page"},{"location":"#Derivates","page":"Home","title":"Derivates","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Whereas zonal derivatives and the Laplacian are computed in the SH domain, meridional derivatives are computed pseudo-spectrally with pre-computed values of the derivatives of the associated Legendre polynomials. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"All derivatives follow a common naming scheme: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"SHtoSH_dλ(ψ_0, qg3) # zonal derivative SH -> SH \nSHtoGrid_dλ(ψ_0, qg3) # zonal derivative SH -> Grid\nSHtoGrid_dμ(ψ_0, qg3) # meridional (μ = sin(latitude)) derivative SH -> Grid \nSHtoGrid_dθ(ψ_0, qg3) # meridional (colatitude) derivative SH -> Grid \nΔ(ψ_0, qg3) # Laplacian SH -> SH","category":"page"},{"location":"#Transforms-and-Derivates-for-Machine-Learning","page":"Home","title":"Transforms and Derivates for Machine Learning","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Outside of the QG3 Model itself the transforms and derivative can also be used for ML tasks. For this purpose the constructors also allow to define them for more horizonatal levels and also for an additional (batch) dimension. The batch dimensions is added as a forth dimension, thus defining transforms and derivaties for fields (lvl x N_lat x N_lon x N_batch). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Either, the transforms and derivatives are initialized directly with the approatite N_level and N_batch input arguments via ","category":"page"},{"location":"","page":"Home","title":"Home","text":"QG3.GaussianGridtoSHTransform\nQG3.SHtoGaussianGridTransform\nQG3.Derivative_dλ\nQG3.GaussianGrid_dμ\nQG3.Laplacian","category":"page"},{"location":"#QG3.GaussianGridtoSHTransform-index","page":"Home","title":"QG3.GaussianGridtoSHTransform","text":"GaussianGridtoSHTransform(p::QG3ModelParameters{T}, N_level::Int=3; N_batch::Int=0)\n\nReturns transform struct, that can be used with transform_SH. Transforms Gaussian Grid data to real spherical harmonics coefficients that follow the coefficient logic explained in the main documenation.\n\nAdditional input arguments:\n\nN_level: defines the transform for N_level horizontal levels. Has to be equal to three for the QG3 model itself, but might be different for other applications. \nN_batch: defines the transforms with an additional batch dimension for ML tasks, if N_batch==0 this is omitted\n\n\n\n\n\n","category":"type"},{"location":"#QG3.SHtoGaussianGridTransform-index","page":"Home","title":"QG3.SHtoGaussianGridTransform","text":"SHtoGaussianGridTransform(p::QG3ModelParameters{T}, N_level::Int=3; N_batch::Int=0)\n\nReturns transform struct, that can be used with transform_grid. Transforms real spherical harmonics coefficients to Gaussian grid data, follows the coefficient logic explained in the main documenation.\n\nAdditional input arguments:\n\nN_level: defines the transform for N_level horizontal levels. Has to be equal to three for the QG3 model itself, but might be different for other applications. \nN_batch: defines the transforms with an additional batch dimension for ML tasks, if N_batch==0 this is omitted\n\n\n\n\n\n","category":"type"},{"location":"#QG3.Derivative_dλ-index","page":"Home","title":"QG3.Derivative_dλ","text":"Derivative_dλ(p::QG3ModelParameters{T}; N_batch::Int=0)\n\nPre-computes Derivatives by longitude. Uses the SH relation, is therefore independ from the grid.\n\n\n\n\n\n","category":"type"},{"location":"#QG3.GaussianGrid_dμ-index","page":"Home","title":"QG3.GaussianGrid_dμ","text":"GaussianGrid_dμ(p::QG3ModelParameters{T}, N_level::Int=3; N_batch::Int=0)\n\nPre-computes Pseudo-spectral approach to computing derivatives with repsect to μ = sin(lats). Derivatives are called with following the naming scheme: \"Domain1Input\"to\"Domain2Output\"_d\"derivativeby\"\n\n\n\n\n\n","category":"type"},{"location":"#QG3.Laplacian-index","page":"Home","title":"QG3.Laplacian","text":"Laplacian(p::QG3ModelParameters{T}; init_inverse=false, R::T=T(1), N_batch::Int=0, kwargs...) where T\n\nInitializes the Laplacian in spherical harmonics and if init_inverse==true also its inverse\n\nApply the Laplacian with the functions (@ref)[Δ] and (@ref)[Δ⁻¹]\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"or a they can be constructed all together via ","category":"page"},{"location":"","page":"Home","title":"Home","text":"QG3.grid ","category":"page"},{"location":"#QG3.grid-index","page":"Home","title":"QG3.grid","text":"grid(p::QG3ModelParameters{T}, gridtype::String, N_level::Int=3; N_batch::Int=0, kwargs...)\n\nConvience constructor for the AbstractGridType based on the parameters set in p.\n\n\n\n\n\n","category":"function"}]
}
