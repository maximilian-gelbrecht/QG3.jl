<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · QG3</title><meta name="title" content="Home · QG3"/><meta property="og:title" content="Home · QG3"/><meta property="twitter:title" content="Home · QG3"/><meta name="description" content="Documentation for QG3."/><meta property="og:description" content="Documentation for QG3."/><meta property="twitter:description" content="Documentation for QG3."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="QG3 logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>QG3</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#The-Model"><span>The Model</span></a></li><li><a class="tocitem" href="#Solvers"><span>Solvers</span></a></li><li><a class="tocitem" href="#Initialize-a-model"><span>Initialize a model</span></a></li><li><a class="tocitem" href="#GPU-and-CPU"><span>GPU and CPU</span></a></li></ul></li><li><a class="tocitem" href="ref/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/maximilian-gelbrecht/QG3.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/maximilian-gelbrecht/QG3.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="QG3.jl"><a class="docs-heading-anchor" href="#QG3.jl">QG3.jl</a><a id="QG3.jl-1"></a><a class="docs-heading-anchor-permalink" href="#QG3.jl" title="Permalink"></a></h1><p>This package provides a Julia implementation of the <a href="https://journals.ametsoc.org/view/journals/atsc/50/12/1520-0469_1993_050_1792_taduop_2_0_co_2.xml">Marshall, Molteni Quasigeostrophic Atmsopheric Model in three layers</a>. It runs on CPU or CUDA GPUs and is differentiable via Zygote.jl.</p><p>The model is solved with a pseudo-spectral approach on a Gaussian grid with approatiate spherical harmonics transforms defined. Example scripts are provided in the <code>examples</code> folder.</p><p>Install e.g. via <code>]add https://github.com/maximilian-gelbrecht/QG3.jl.git</code> and test the installation with <code>]test QG3</code></p><p>The repository includes pre-computed forcing and initial conditions on a T21 to run the model but no proper dataset to compute re-compute those in order to save space. The example folder also includes the necessary scripts to pre-copmute those for other grids and datasets. </p><h2 id="The-Model"><a class="docs-heading-anchor" href="#The-Model">The Model</a><a id="The-Model-1"></a><a class="docs-heading-anchor-permalink" href="#The-Model" title="Permalink"></a></h2><p>Details about the model can be read up in &quot;Towards a Dynamical Understanding of Planetary-Scale Flow Regimes&quot;, Marshall, Molteni, Journal of Atmsopheric Sciences, 1992.</p><p>Its governing equation for the quasigeostrophic vorticity <span>$`q_i`$</span> in three equipressure levels (200, 500, 800 hPa) are given by</p><p class="math-container">\[\dot{q_i} = -J(\psi_i, q_i) - D(\psi_i, q_i) + S \\
\vec{q} = T_{\psi q} \vec{\psi},\]</p><p>where the voriticy <span>$q$</span> and streamfunction <span>$\psi$</span> are related by a linear operator (comprising the Laplacian and temperature relaxation), <span>$J$</span> is the Jacobian / advection term, <span>$D$</span> the dissipation and <span>$S$</span> a forcing computed from data.</p><h2 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h2><p>This packages includes all function necessary to define the governing equation of the QG3 Model. It does however, not include the differential equations solvers, for those we rely on <code>DifferentialEquations.jl</code>, i.e. <code>OrdinaryDiffEq.jl</code>. In the following, we will therefore briefly talk about how to define the right hand side necessary to define for those solvers, before going into a little more detail on the transforms and derivatives used throughout the model. </p><h2 id="Initialize-a-model"><a class="docs-heading-anchor" href="#Initialize-a-model">Initialize a model</a><a id="Initialize-a-model-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-a-model" title="Permalink"></a></h2><p>The model parameter are hold as <a href="ref/#QG3.QG3ModelParameters"><code>QG3ModelParameters</code></a>: </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QG3.QG3ModelParameters-index" href="#QG3.QG3ModelParameters-index"><code>QG3.QG3ModelParameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QG3ModelParameters{T}</code></pre><p>Saves all the parameters of the model, also the units/normalization. </p><p><strong>Fields</strong></p><ul><li><code>L::Int</code>: number of SH number l, note that 0,...,l<em>max, so that L is l</em>max + 1</li><li><code>M::Int</code>: # maximum number M values, M==2<em>L - 1 / 2</em>l_max + 1</li><li><code>N_lats::Int</code></li><li><code>N_lons::Int</code></li><li><code>lats::AbstractArray{T,1}</code></li><li><code>θ::AbstractArray{T,1}</code> colatitudes = θ</li><li><code>μ::AbstractArray{T,1}</code> sin(lats) == cos(colats)</li><li><code>LS::AbstractArray{T,2}</code> Land see mask, on the same grid as lats and lons</li><li><code>h::AbstractArray{T,2}</code>` orography, array on the same grid as lats and lons</li><li><code>R1i::T</code> square inverse of Rossby radius 1 200-500hPa, default 1/(700km)^2</li><li><code>R2i::T</code> square inverse of Rossby radius 2 500-800hPa, default 1/(450km)^2</li><li><code>H0::T</code> scaling parameter for topography, default 9000m</li><li><code>τRi::T</code> inverse of radiative time scale, default 1/(25d)</li><li><code>τEi::T</code> inverse of drag time scale, default 1/(3d)</li><li><code>cH::T</code> horizonatal diffusion coefficient</li><li><code>α1::T</code> drag coefficient 1, default 0.5</li><li><code>α2::T</code> drag coefficient 2, default 0.5</li><li><code>gridtype::String</code> either &#39;gaussian&#39; or &#39;regular&#39;, &#39;gaussian&#39; leads to all transform being done by somewhat naively implemented transforms, &#39;regular&#39; uses FastTransforms.jl</li><li><code>time_unit::T</code> unit so that t [normalized] = t [d] / time_unit, default = 1 / 4π</li><li><code>distance_unit::T</code>, default Earth&#39;s radius, so that s [normalized] = s [m] / distance_unit, default = 6.371e6</li><li><code>ψ_unit::T</code>, derived from time<em>unit and distance</em>unit, so that ψ [normalized] = ψ [m^2/s] / ψ_unit</li><li><code>q_unit::T</code>, derived from time<em>unit and distance</em>unit</li></ul><p><strong>Other constructors</strong></p><pre><code class="nohighlight hljs">QG3ModelParameters(L::Int, lats::AbstractArray{T,1}, lons::AbstractArray{T,1}, LS::AbstractArray{T,2}, h::AbstractArray{T,2}, R1i::T, R2i::T, H0::T, τRi::T, τEi::T, τHi::T, α1::T, α2::T, a::T, gridtype::String, time_unit::T, distance_unit::T)</code></pre><p>Default arguments for most parameters, so that</p><pre><code class="nohighlight hljs">QG3ModelParameters(L::Int, lats::AbstractArray{T,1}, lons::AbstractArray{T,1}, LS::AbstractArray{T,2}, h::AbstractArray{T,2})</code></pre><p>works as well.</p><p><strong>Normalization/units of the model</strong></p><p>The model is normalized in (natural) units of the system. </p><ul><li>Distance: The Earth&#39;s radius is set to <code>1</code> (and thus all units containing distance are scaled with the actual radius of the Earth)</li><li>Vorticity: Earth&#39;s angular speed is approximately 2π/d, here Earth&#39;s angular speed is set 2Ω = 1, so that the planetery vorticity component of the Jacobian is just ∂ψ/∂λ. Therefore: Ω = 1/2, it follows 2*2π [1/d] = 1 [Ω<em>normalized], therefore Ω</em>normalized = 4π/d. </li><li>Time: From the vorticity unit, follows the time unit is [d/4π] = [d<em>normalized]. Hence, time in days must be devided by 4π to get the natural time unit, or [d</em>normalized] = 4π [d]</li><li>both ψ and q thus need to expressed in these units too, this can be done using the <code>ψ_unit</code> and <code>q_unit</code>    </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/QG3.jl/blob/b427fd8474a9a07962fc7574ba88c10067094680/src/basic_types.jl#L5-L53">source</a></section></article><p>For convenience, a pre-computed setup with forcing <code>S</code>, parameters <code>qg3_pars</code> and initial conditions <code>ψ_0</code>, <code>q_0</code> can be loaded via </p><pre><code class="language-julia hljs">S, qg3_pars, ψ_0, q_0 = QG3.load_precomputed_data(GPU=false)</code></pre><p>Alternatively, the <code>pre-compute.jl</code> script in the examples folder demonstrates how to compute those from other datasets and for other resolutions. </p><p>Then, the model can be pre-computed with the help of <a href="ref/#QG3.QG3Model"><code>QG3Model</code></a></p><pre><code class="language-julia hljs">qg3 = QG3Model(qg3_pars)</code></pre><p>or on GPU </p><pre><code class="language-julia hljs">qg3 = CUDA.@allowscalar QG3Model(qg3_pars) # on GPU the pre-computation need scalar indexing</code></pre><p>These struct also hold the grid information <code>qg3.g</code> that comprises all transforms and derivatives. </p><h2 id="GPU-and-CPU"><a class="docs-heading-anchor" href="#GPU-and-CPU">GPU and CPU</a><a id="GPU-and-CPU-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-and-CPU" title="Permalink"></a></h2><p>Currently there are two different implementations, one that is optimised for CPU (the &quot;2D version&quot;) and one that is optimised for GPU (the &quot;3D version&quot;). The GPU version can also run on CPU but not the other way around.</p><p>The GPU is automatically detected. If you wish to run the model on CPU on a computer that does have a CUDA capable GPU, then you can turn it of with <code>QG3.gpuoff()</code> before model pre-computation. </p><h3 id="GPU-Version"><a class="docs-heading-anchor" href="#GPU-Version">GPU Version</a><a id="GPU-Version-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Version" title="Permalink"></a></h3><p>The GPU version is fully vectorized, without scalar indexing. All needed functions work on the 3d (level, lat, lon) / (level, il, m) field. The full problem definition thus is just simply</p><pre><code class="language-julia hljs">function QG3MM_gpu(q, m, t)
    p, S = m # parameters, forcing vector

    ψ = qprimetoψ(p, q)
    return - J(ψ, q, p) - D(ψ, q, p) + S
end</code></pre><p>This right hand side calls the transform from potential vorticity to the streamfunction <a href="ref/#QG3.qprimetoψ-Union{Tuple{T}, Tuple{QG3Model{T, P, G, M, A} where {P&lt;:QG3ModelParameters, G&lt;:QG3.AbstractGridType, M&lt;:AbstractMatrix{T}, A&lt;:AbstractArray{T, 3}}, AbstractArray{T, 3}}} where T"><code>qprimetoψ</code></a>, the advection operator <a href="ref/#QG3.J-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}, QG3Model{T, P, G, M, A} where {P&lt;:QG3ModelParameters, G&lt;:QG3.AbstractGridType, M&lt;:AbstractMatrix{T}, A&lt;:AbstractArray{T, 3}}}} where T"><code>J</code></a>, the dissipation operator <a href="ref/#QG3.D-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}, QG3Model{T, P, G, M, A} where {P&lt;:QG3ModelParameters, G&lt;:QG3.AbstractGridType, M&lt;:AbstractMatrix{T}, A&lt;:AbstractArray{T, 3}}}} where T"><code>D</code></a> and the pre-computed forcing <code>S</code>. </p><h3 id="CPU-Version"><a class="docs-heading-anchor" href="#CPU-Version">CPU Version</a><a id="CPU-Version-1"></a><a class="docs-heading-anchor-permalink" href="#CPU-Version" title="Permalink"></a></h3><p>The CPU version works on 2d fields (lat, lon) / (il, m), on CPUs this is currently a little faster than using the GPU/3D version on CPU. In other words: the GPU version could probably still be optimized further. The problem definition follows as</p><pre><code class="language-julia hljs">function QG3MM_base(q, m, t)
    p, S = m # parameters, forcing vector

    ψ = qprimetoψ(p, q)
    return cat(
    reshape(- J(ψ[1,:,:], q[1,:,:], p) .- D1(ψ, q, p) .+ S[1,:,:], (1, p.p.L, p.p.M)),
    reshape(- J(ψ[2,:,:], q[2,:,:], p) .- D2(ψ, q, p) .+ S[2,:,:], (1, p.p.L, p.p.M)),
    reshape(- J3(ψ[3,:,:], q[3,:,:], p) .- D3(ψ, q, p) .+ S[3,:,:], (1, p.p.L, p.p.M)),
    dims=1)
end</code></pre><h3 id="Model-Units"><a class="docs-heading-anchor" href="#Model-Units">Model Units</a><a id="Model-Units-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Units" title="Permalink"></a></h3><p>This implemenation uses a unit system, so that the Earth&#39;s radius and angular velocity equals</p><p class="math-container">\[\begin{aligned}
R = 1 \\
2\Omega = 1,
\end{aligned}\]</p><p>from these follow the units for all variables. The parameter struct holds those as <code>qg3_pars.time_unit</code>, <code>qg3_pars.distance_unit</code>, <code>qg3_pars.ψ_unit</code> and <code>qg3_pars.q_unit</code>. </p><h3 id="Transforms"><a class="docs-heading-anchor" href="#Transforms">Transforms</a><a id="Transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Transforms" title="Permalink"></a></h3><p>Throughout the model real spherical harmonics are used. The transform is implemented with a FFT and a Gauss-Legendre transform that is solved by pre-computing the associated Legendre polynomials and then executing the appropiate matrix multiplication for the transform. This ensures both differentiability and GPU compatability of the transforms. Gradients of the spherical harmonics transforms are checked against finite difference differentiation in the tests.  </p><p>Transforms are called with <a href="ref/#QG3.transform_SH"><code>transform_SH</code></a> and <a href="ref/#QG3.transform_grid"><code>transform_grid</code></a>, e.g. as in the following: </p><pre><code class="language-julia hljs">ψ_0_grid = transform_grid(ψ_0, qg3)
ψ_0_SH = transform_SH(ψ_0_grid, qg3)</code></pre><p>SHs coefficients on CPU are handled in the matrix convention that FastTransforms.jl uses: columns by m-value: 0, -1, 1, -2, 2, ..., rows l in ascending order. This was implemented initially during development to ensure compatability with FastTransforms.jl, unfortunately however, using FastTransforms.jl isn&#39;t currently working (yet) due to aliasing problems. On GPU, we store the coefficients differently to avoid additional operations to reorder all coefficents that would be needed otherwise with the CUFFT routines. Therefore the coefficient matrix convention is different on GPU, where the columns are ordered 0, 1, 2, .... l_max, 0, -1, -2, -3, .. . </p><h3 id="Derivates"><a class="docs-heading-anchor" href="#Derivates">Derivates</a><a id="Derivates-1"></a><a class="docs-heading-anchor-permalink" href="#Derivates" title="Permalink"></a></h3><p>Whereas zonal derivatives and the Laplacian are computed in the SH domain, meridional derivatives are computed pseudo-spectrally with pre-computed values of the derivatives of the associated Legendre polynomials. </p><p>All derivatives follow a common naming scheme: </p><pre><code class="language-julia hljs">SHtoSH_dλ(ψ_0, qg3) # zonal derivative SH -&gt; SH 
SHtoGrid_dλ(ψ_0, qg3) # zonal derivative SH -&gt; Grid
SHtoGrid_dμ(ψ_0, qg3) # meridional (μ = sin(latitude)) derivative SH -&gt; Grid 
SHtoGrid_dθ(ψ_0, qg3) # meridional (colatitude) derivative SH -&gt; Grid 
Δ(ψ_0, qg3) # Laplacian SH -&gt; SH</code></pre><h3 id="Transforms-and-Derivates-for-Machine-Learning"><a class="docs-heading-anchor" href="#Transforms-and-Derivates-for-Machine-Learning">Transforms and Derivates for Machine Learning</a><a id="Transforms-and-Derivates-for-Machine-Learning-1"></a><a class="docs-heading-anchor-permalink" href="#Transforms-and-Derivates-for-Machine-Learning" title="Permalink"></a></h3><p>Outside of the QG3 Model itself the transforms and derivative can also be used for ML tasks. For this purpose the constructors also allow to define them for more horizonatal levels and also for an additional (batch) dimension. The batch dimensions is added as a forth dimension, thus defining transforms and derivaties for fields <code>(lvl x N_lat x N_lon x N_batch)</code>. </p><p>Either, the transforms and derivatives are initialized directly with the approatite <code>N_level</code> and <code>N_batch</code> input arguments via </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QG3.GaussianGridtoSHTransform-index" href="#QG3.GaussianGridtoSHTransform-index"><code>QG3.GaussianGridtoSHTransform</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianGridtoSHTransform(p::QG3ModelParameters{T}, N_level::Int=3; N_batch::Int=0)</code></pre><p>Returns transform struct, that can be used with <code>transform_SH</code>. Transforms Gaussian Grid data to real spherical harmonics coefficients that follow the coefficient logic explained in the main documenation.</p><p><strong>Additional input arguments:</strong></p><ul><li><code>N_level</code>: defines the transform for <code>N_level</code> horizontal levels. Has to be equal to three for the QG3 model itself, but might be different for other applications. </li><li><code>N_batch</code>: defines the transforms with an additional batch dimension for ML tasks, if <code>N_batch==0</code> this is omitted</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/QG3.jl/blob/b427fd8474a9a07962fc7574ba88c10067094680/src/transforms.jl#L121-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QG3.SHtoGaussianGridTransform-index" href="#QG3.SHtoGaussianGridTransform-index"><code>QG3.SHtoGaussianGridTransform</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SHtoGaussianGridTransform(p::QG3ModelParameters{T}, N_level::Int=3; N_batch::Int=0)</code></pre><p>Returns transform struct, that can be used with <code>transform_grid</code>. Transforms real spherical harmonics coefficients to Gaussian grid data, follows the coefficient logic explained in the main documenation.</p><p><strong>Additional input arguments:</strong></p><ul><li><code>N_level</code>: defines the transform for <code>N_level</code> horizontal levels. Has to be equal to three for the QG3 model itself, but might be different for other applications. </li><li><code>N_batch</code>: defines the transforms with an additional batch dimension for ML tasks, if <code>N_batch==0</code> this is omitted</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/QG3.jl/blob/b427fd8474a9a07962fc7574ba88c10067094680/src/transforms.jl#L229-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QG3.Derivative_dλ-index" href="#QG3.Derivative_dλ-index"><code>QG3.Derivative_dλ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Derivative_dλ(p::QG3ModelParameters{T}; N_batch::Int=0)</code></pre><p>Pre-computes Derivatives by longitude. Uses the SH relation, is therefore independ from the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/QG3.jl/blob/b427fd8474a9a07962fc7574ba88c10067094680/src/derivatives.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QG3.GaussianGrid_dμ-index" href="#QG3.GaussianGrid_dμ-index"><code>QG3.GaussianGrid_dμ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianGrid_dμ(p::QG3ModelParameters{T}, N_level::Int=3; N_batch::Int=0)</code></pre><p>Pre-computes Pseudo-spectral approach to computing derivatives with repsect to μ = sin(lats). Derivatives are called with following the naming scheme: &quot;Domain1Input&quot;to&quot;Domain2Output&quot;_d&quot;derivativeby&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/QG3.jl/blob/b427fd8474a9a07962fc7574ba88c10067094680/src/derivatives.jl#L134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QG3.Laplacian-index" href="#QG3.Laplacian-index"><code>QG3.Laplacian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Laplacian(p::QG3ModelParameters{T}; init_inverse=false, R::T=T(1), N_batch::Int=0, kwargs...) where T</code></pre><p>Initializes the <code>Laplacian</code> in spherical harmonics and if <code>init_inverse==true</code> also its inverse</p><p>Apply the Laplacian with the functions (@ref)[<code>Δ</code>] and (@ref)[<code>Δ⁻¹</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/QG3.jl/blob/b427fd8474a9a07962fc7574ba88c10067094680/src/derivatives.jl#L228-L234">source</a></section></article><p>or a they can be constructed all together via </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QG3.grid-index" href="#QG3.grid-index"><code>QG3.grid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid(p::QG3ModelParameters{T}, gridtype::String, N_level::Int=3; N_batch::Int=0, kwargs...)</code></pre><p>Convience constructor for the <a href="ref/#QG3.AbstractGridType"><code>AbstractGridType</code></a> based on the parameters set in <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/QG3.jl/blob/b427fd8474a9a07962fc7574ba88c10067094680/src/basic_types.jl#L142-L146">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="ref/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 20 January 2025 10:55">Monday 20 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
