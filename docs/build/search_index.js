var documenterSearchIndex = {"docs":
[{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [QG3]\nOrder   = [:type, :function]","category":"page"},{"location":"ref/#QG3.AbstractGridType","page":"Reference","title":"QG3.AbstractGridType","text":"AbstractGridType{T, onGPU}\n\nAbstract type for grids. The grids save information about the transform from the spatial to spectral grid, e.g. pre-computed Legendre Polynomials\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.ContinousTimeForcing","page":"Reference","title":"QG3.ContinousTimeForcing","text":"TimeForcing\n\nTime-dependent Forcing\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.QG3Model","page":"Reference","title":"QG3.QG3Model","text":"QG3Model{T}\n\nHolds all parameter and grid information, plus additional pre-computed fields that save computation time during model integration\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.QG3Model-Tuple{QG3ModelParameters}","page":"Reference","title":"QG3.QG3Model","text":"QG3Model(p::QG3ModelParameters)\n\nRoutine that pre computes the QG3 Model and returns a QG3Model struct with all precomputed fields except for the forcing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.QG3ModelParameters","page":"Reference","title":"QG3.QG3ModelParameters","text":"QG3ModelParameters{T}\n\nSaves all the parameters of the model\n\nFields\n\n* `L::Int`: number of SH number l, note that 0,...,l_max, so that L is l_max + 1\n* `M::Int`: # maximum number M values, M==2*L - 1 / 2*l_max + 1\n* `N_lats::Int`\n* `N_lons::Int`\n* `lats::AbstractArray{T,1}`\n* `colats::AbstractArray{T,1}` colatitudes = θ\n* `μ::AbstractArray{T,1}` sin(lats) == cos(colats)\n* `LS::AbstractArray{T,2}` Land see mask, on the same grid as lats and lons\n* `h::AbstractArray{T,2}`` orography, array on the same grid as lats and lons\n* `R1i::T` square inverse of Rossby radius 1 200-500hPa, default 1/(700km)^2\n* `R2i::T` square inverse of Rossby radius 2 500-800hPa, default 1/(450km)^2\n* `H0::T` scaling parameter for topography, default 9000m\n* `τRi::T` inverse of radiative time scale, default 1/(25d)\n* `τEi::T` inverse of drag time scale, default 1/(3d)\n* `cH::T` horizonatal diffusion coefficient\n* `α1::T` drag coefficient 1, default 0.5\n* `α2::T` drag coefficient 2, default 0.5\n* `a::T` Earth's radius  # WIP: some functions assume a=1\n* `Ω::T` Earth's angular speed for Coriolis # WIP: some functions assume Ω=1/2\n* `gridtype::String` either 'gaussian' or 'regular', 'gaussian' leads to all transform being done by somewhat naively implemented transforms, 'regular' uses FastTransforms.jl\n* `time_unit::T` unit so that t [normalized] = t [s] / time_unit, default = 1/4π\n* `distance_unit::T`, default Earth's radius\n* `ψ_unit::T`, derived from time_unit and distance_unit\n* `q_unit::T`, derived from time_unit and distance_unit\n\nOther constructors\n\nQG3ModelParameters(L::Int, lats::AbstractArray{T,1}, lons::AbstractArray{T,1}, LS::AbstractArray{T,2}, h::AbstractArray{T,2}, R1i::T, R2i::T, H0::T, τRi::T, τEi::T, τHi::T, α1::T, α2::T, a::T, Ω::T, gridtype::String, time_unit::T, distance_unit::T)\n\nDefault arguments for most parameters, so that\n\nQG3ModelParameters(L::Int, lats::AbstractArray{T,1}, lons::AbstractArray{T,1}, LS::AbstractArray{T,2}, h::AbstractArray{T,2})\n\nworks as well.\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.EK-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.EK","text":"Ekman dissipation\n\nEK = ∇(k∇ψ) = (∇k ∇ψ) + k Δψ  EK = 1/a^2cos^2ϕ ∂k/∂λ ∂ψ/∂λ + 1/a^2 ∂k/∂ϕ ∂ψ/∂ϕ + k Δψ   (a==1)\n\nm.∂k∂λ  includes 1/cos^2ϕ\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.EK3_simple-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.EK3_simple","text":"Simplified Ekman dissipiation for k(ϕ,λ) = const\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.H-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.H","text":"Horizontal diffusion, q' is anomolous pv (without coriolis)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.J-Tuple{Any, Any, QG3Model}","page":"Reference","title":"QG3.J","text":"Compute the Jacobian determinant from ψ and q in μ,λ coordinates, J = ∂ψ/∂x ∂q/∂y - ∂ψ/∂y ∂q/∂x = 1/a^2cosϕ ( - ∂ψ/∂λ ∂q/∂ϕ + ∂ψ/∂ϕ ∂q/∂λ) =  1/a^2 (- ∂ψ/∂λ ∂q/∂μ + ∂ψ/∂μ ∂q/∂λ)\n\nThe last term ∂ψ/∂λ accounts for the planetery vorticity, actually it is 2Ω ∂ψ/∂λ, but 2Ω == 1, (write q = q' + 2Ωμ to proof it)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.J3-Tuple{Any, Any, QG3Model}","page":"Reference","title":"QG3.J3","text":"For the Jacobian at 850hPa, q = q' + f(1+h/H0) = q' + f + f*h/H0, so that the thrid term has to be added.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.J_F-Tuple{Any, Any, QG3Model}","page":"Reference","title":"QG3.J_F","text":"Compute the Jacobian determinant from ψ and q in μ,λ coordinates without the planetary vorticity, as used in computing the eddy/transient forcing\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.QG3MM_adv-Tuple{Any, Any, Any}","page":"Reference","title":"QG3.QG3MM_adv","text":"QG3MM_adv(q, p, t)\n\nJust the Advection\n\ndq = - J(ψ,q)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.QG3MM_base-Tuple{Any, Any, Any}","page":"Reference","title":"QG3.QG3MM_base","text":"QG3MM_base(q, p, t)\n\nBase model used in the MM paper, with symmetrization around the equator\n\ndq = - J(ψ,q) - D(ψ,q) + S\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoGrid_dθ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.SHtoGrid_dθ","text":"derivative of input after θ (azimutal angle/colatitude) in SH, uses pre computed SH evaluations (dependend on the grid type)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoGrid_dμ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.SHtoGrid_dμ","text":"derivative of input after μ = sinϕ in SH, uses pre computed SH evaluations\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoGrid_dφ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.SHtoGrid_dφ","text":"derivative of input after φ (polar angle) or λ (longtitude) in SH to Grid, only for a single layer\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoSH_dφ-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Integer, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.SHtoSH_dφ","text":"derivative of input after φ (polar angle/longtitude) in SH, output in SH\n\nthese are  variants with AbstractArray{T,3} and index i to select which layer is the input for the derivative.\n\nthere is currently a bug or at least missing feature in Zygote, the AD library, that stops views from always working flawlessly when a view is mixed with prior indexing of an array. We need a view for the derivative after φ to change the sign of m, so here is a differentiable variant of the SHtoSH_dφ function\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoSH_dφ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.SHtoSH_dφ","text":"derivative of input after φ (polar angle/longtitude) in SH, output in SH\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.TR-Union{Tuple{T}, Tuple{QG3Model{T}, Any, Any, T}} where T<:Number","page":"Reference","title":"QG3.TR","text":"Temperature relaxation\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3._SHtoGrid_dμθ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{T, 3}, QG3ModelParameters, QG3.AbstractGridType{T, false}}} where T<:Number","page":"Reference","title":"QG3._SHtoGrid_dμθ","text":"Performs the latitude-based derivates. Uses a form of synthesis based on pre-computed values of the ass. Legendre polynomials at the grid points.\n\nThis version is optimized to be non-mutating with batchedvec. The inner batchedvec correspodends to an inverse Legendre transform and the outer multiply to an inverse Fourier transform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.change_msign!-Tuple{Any}","page":"Reference","title":"QG3.change_msign!","text":"change_msign(A)\n\nChange the sign of the m in SH (FastTranforms.jl convention of storing them). This version swaps the columns inplace\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.change_msign-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T<:Number","page":"Reference","title":"QG3.change_msign","text":"change_msign(A)\n\nChange the sign of the m in SH (FastTranforms.jl convention of storing them). This version returns a view\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_GaussWeights-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T<:Number","page":"Reference","title":"QG3.compute_GaussWeights","text":"Pre-computes gaussian weights for Legendre Transform, also checks if we really have the correct gaussian latitudes\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_P-Union{Tuple{T}, Tuple{Integer, Integer, AbstractVector{T}}} where T<:Number","page":"Reference","title":"QG3.compute_P","text":"Pre-compute ass. Legendre Polynomials and dP/dx (derivative of ass. Legendre Polynomial) at the grid points and also the remainder of the Spherical Harmonics at the grid points using GSL\n\nm values are stored 0,-1,1,-2,2,-3,3,...\n\ndouble check -m values , so far only |m| is used, as I assume real SPH.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_S_Roads-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.compute_S_Roads","text":"Pre-compute Forcing S data level,X,Y,t\n\nCompute the forcing according to Roads, this is outlined in the MM and Corti paper as well.\n\nThis uses an unfiltered version, in the Corti paper there is a filter. Maybe implement it as well\n\ndata, input data\nm, QG3Model Parameters and pre-computed fields\nkwargs\ndatasource, either 'qprime' (anomalous potential vorticity) or 'sf' (streamfunction)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_S_t_corti","page":"Reference","title":"QG3.compute_S_t_corti","text":"Pre-compute time-dependent Forcing S data level,X,Y,t\n\nLike in the Corti paper for the seasonal run this interpolates between two extremal forcings.\n\nNt_year: how many days does a year have / period length of the sinus\n\n\n\n\n\n","category":"function"},{"location":"ref/#QG3.compute_TR-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_TR","text":"Pre-compute array of temperature relaxation coefficients.\n\n(l=0, m=0)-coefficient is assigned zero. This results in this expansion coefficient beeing constant in the whole model.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_acosϕi-Tuple{QG3ModelParameters}","page":"Reference","title":"QG3.compute_acosϕi","text":"Pre-compute (a*cos(ϕ))^-1 (latitude matrix)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_batched_ψq_transform_matrices-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T<:Number","page":"Reference","title":"QG3.compute_batched_ψq_transform_matrices","text":"compute_batched_ψq_transform_matrices\n\nprepares the transform from q to ψ and back for a batched matrix vector multiply, see also (@ref)[compute_ψq_transform_matrices]\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_coriolis_vector_SH-Tuple{QG3ModelParameters, Any, Any, Any}","page":"Reference","title":"QG3.compute_coriolis_vector_SH","text":"Pre-compute a matrix with with the Coriolis factor\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_cosϕ-Tuple{QG3ModelParameters}","page":"Reference","title":"QG3.compute_cosϕ","text":"Pre-compute cos(ϕ) (latitude) matrix\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_k-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_k","text":"Pre-compute drag coefficient k in real grid space, double check with values from paper\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_mmMatrix-Union{Tuple{T}, Tuple{Integer, Integer}} where T<:Number","page":"Reference","title":"QG3.compute_mmMatrix","text":"Pre-compute a matrix with (m) values of the SH matrix format of FastTransforms.jl, used for zonal derivative\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_Δ-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_Δ","text":"Pre-compute the Laplacian in Spherical Harmonics, follows the matrix convention of FastTransforms.jl\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_ψq_transform_matrices-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T<:Number","page":"Reference","title":"QG3.compute_ψq_transform_matrices","text":"Pre-compute matrices involved in transforming vorticity to streamfunction and back\n\nq = Tψq * ψ + f ψ = Tqψ * (q - f) = Tψq^(-1) * (q - f)\n\nFor l=0 the matrix is singular. In the fortran code they set q to something which for me does not make sense. Here Tψq(l=0) is just 1, so that transforming back and forth recovers the correct ψ. This makes sense in my eyes because q is only ever used for its spatial derivatives, all of which are 0 for l=0.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_∇8-Tuple{QG3ModelParameters}","page":"Reference","title":"QG3.compute_∇8","text":"\" Pre-compute the 8-th derivative in Spherical Harmonics\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.lMatrix-Tuple{Any, Any}","page":"Reference","title":"QG3.lMatrix","text":"Return l-Matrix of SH coefficients in convention of FastTransforms.jl\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.level_index-Tuple{Any, Any}","page":"Reference","title":"QG3.level_index","text":"level_index(strings,lvls)\n\nHelper function for indexing netcdf files with many levels.\n\nstring, array with name of levels to be selected\nlvls, array with all levels\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.qprimetoψ-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T<:Number","page":"Reference","title":"QG3.qprimetoψ","text":"Convert the anomalous potential vorticity q' to streamfunction ψ\n\nThis version is slightly slower than the old one (as it not aware of the matrix being half full of zeroes), but it is non-mutating which makes it suitable for the automatic differentation.\n\nIt replaces the double loop over the coefficient matrix with a batched vector multiply. The advantage of that is that it is optimised for GPU, so it might actually be faster on the GPU than doing a manual loop.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.qtoψ-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T<:Number","page":"Reference","title":"QG3.qtoψ","text":"Convert the potential vorticity q to streamfunction ψ\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.sph_zero_spurious_modes!-Tuple{AbstractMatrix{T} where T}","page":"Reference","title":"QG3.sph_zero_spurious_modes!","text":"Sets the unphysical numbers zero (usually only needed for FastTransforms.jl)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.transformGGridtoSH-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3ModelParameters{T}, QG3.GaussianGrid{T, false}}} where T<:Number","page":"Reference","title":"QG3.transformGGridtoSH","text":"manually implemented transfrom from grid to spherical space, so far only for gaussian grid\n\nCPU variant\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.transformGGridtoSH-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3ModelParameters{T}, QG3.GaussianGrid{T, true}}} where T<:Number","page":"Reference","title":"QG3.transformGGridtoSH","text":"manually implemented transfrom from grid to spherical space, so far only for gaussian grid\n\nGPU variant, r2c fft instead of r2r fft\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.transformSHtoGGrid-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3ModelParameters{T}, QG3.GaussianGrid{T, false}}} where T<:Number","page":"Reference","title":"QG3.transformSHtoGGrid","text":"manually implemented transform from spherical harmonics to grid. This works for all grid types, the grid type is indirectly specified through the pre-computed ass. legendre polynomials\n\nCPU variant\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.transform_SH-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3ModelParameters{T}, QG3.GaussianGrid{T, onGPU} where onGPU}} where T<:Number","page":"Reference","title":"QG3.transform_SH","text":"transform_SH(data, m::QG3Model, varname::String=\"ψ\", setzeros=true)\n\nTransforms the data to spherical harmonics.\n\nif setzeros == true, the \"unphysical\" lower triangle is directly set zero when using FastTransforms.jl\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.transform_grid-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model}} where T<:Number","page":"Reference","title":"QG3.transform_grid","text":"transform_grid(data, m::QG3Model)\n\nTransforms the data to real space\n\nIf varname ∈ [\"pv\",\"q\",\"vorticity\"] the [1,1] element is set to zero first, as this element is set to the streamfunction-[1,1] usually in the ψtoq routines.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.ψtoq-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T<:Number","page":"Reference","title":"QG3.ψtoq","text":"Convert the streamfunction ψ to the potential vorticity\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.ψtoqprime-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T<:Number","page":"Reference","title":"QG3.ψtoqprime","text":"Convert the streamfunction ψ to (anomlous) potential vorticity q' in spherical harmonics basis\n\nThis version is slightly slower than the old one on CPU (as it not aware of the matrix being half full of zeroes), but it is non-mutating which makes it suitable for the automatic differentation.\n\nIt replaces the double loop over the coefficient matrix with a batched vector multiply. The advantage other besides it being non-mutating is that it is optimised for GPU, so it might actually be faster on the GPU than doing a manual loop.\n\n\n\n\n\n","category":"method"},{"location":"#QG3-Model","page":"Home","title":"QG3 Model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This code provides a Julia implementation of the Marshall, Molteni QG3 Model. It runs on GPUs and is differentiable (tested only with Zygote).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The model is solved with a pseudo-spectral approach. Currently there is a naive implemention of Real Spherical Harmonics with transforms defined for a Gaussian Grid. There are bindings to FastTransforms.jl for a regular grid as well, however this is experimental and suffers from aliasing problems when integrating the equation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"So far this documentation is not yet fully fledged out. It just provides the docstrings and some very basic how-to.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Check out the basic_test.jl for a simple minimal example of the running the QG3 system. ","category":"page"}]
}
