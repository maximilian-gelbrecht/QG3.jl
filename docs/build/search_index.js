var documenterSearchIndex = {"docs":
[{"location":"ref/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [QG3]\nOrder   = [:type, :function]","category":"page"},{"location":"ref/#QG3.AbstractGridType","page":"Reference","title":"QG3.AbstractGridType","text":"AbstractGridType{T, onGPU}\n\nAbstract type for grids. The grids save information about the transform from the spatial to spectral grid, e.g. pre-computed Legendre Polynomials\n\nRequired fields: \n\nGtoSH\nSHtoG\ndμ\ndλ\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.AbstractSHTransform","page":"Reference","title":"QG3.AbstractSHTransform","text":"abstract type AbstractSHTransform{onGPU}\n\nRequired fields for all subtypes: \n\noutputsize\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.AbstractμDerivative","page":"Reference","title":"QG3.AbstractμDerivative","text":"abstract type AbstractμDerivative{onGPU} < AbstractDerivative{onGPU} \n\nRequired fields: \n\nmsinθ: To change between μ and latitude derivative (-sin(colats))\nmsinθ_3d: To change between μ and latitude derivative (-sin(colats))\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.ContinousTimeForcing","page":"Reference","title":"QG3.ContinousTimeForcing","text":"TimeForcing\n\nTime-dependent Forcing\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.Derivative_dλ","page":"Reference","title":"QG3.Derivative_dλ","text":"Derivative_dλ\n\nPre-computes Derivatives by longitude. Uses the SH relation, is therefore independ from the grid.\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.GaussianGrid","page":"Reference","title":"QG3.GaussianGrid","text":" GaussianGrid{T, onGPU} <: AbstractGridType{T, onGPU}\n\nStruct for the transforms and derivates of a Gaussian Grid\n\nFields:\n\nGtoSH::GaussianGridtoSHTransform\nSHtoG::GaussianSHtoGridTransform\ndμ::GaussianGrid_dμ\ndλ::Derivative_dλ\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.GaussianGrid_dμ","page":"Reference","title":"QG3.GaussianGrid_dμ","text":"GaussianGrid_dμ(p::QG3ModelParameters{T}, N_level::Int=3)\n\nPre-computes Pseudo-spectral approach to computing derivatives with repsect to μ = sin(lats). Derivatives are called with following the naming scheme: \"Domain1Input\"to\"Domain2Output\"_d\"derivativeby\"\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.GaussianGridtoSHTransform","page":"Reference","title":"QG3.GaussianGridtoSHTransform","text":"GaussianGridtoSHTransform(p::QG3ModelParameters{T}, N_level::Int=3)\n\nReturns transform struct, that can be used with transform_SH. This is one is for a Gaussian Grid.\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.QG3Model","page":"Reference","title":"QG3.QG3Model","text":"QG3Model{T}\n\nHolds all parameter and grid information, plus additional pre-computed fields that save computation time during model integration. All these parameter are seen as constants and not trainable. It should be computed on CPU, if you are on GPU use CUDA.@allowscalar QG3Model(...).\n\nFields\n\np::QG3ModelParameters{T} Parameters of the model\ng::AbstractGridType{T} Grid type with pre-computed plans or Legendre polynomals and co.\nk::AbstractArray{T,2} Array, drag coefficient pre-computed from orography and land-sea mask\nTRcoeffs::AbstractArray{T,3} Array of Temperature relaxation coefficients (2d version)\nTR_matrix Matrix for temperature relaxation (3d version)\ncosϕ::AbstractArray{T,2} cos(latitude) pre computed\nacosϕi::AbstractArray{T,2} inverse of a*cos(latitude) pre computed\nΔ::AbstractArray{T,2} # laplace operator in spherical harmonical coordinates\nTψq matrix used for transforming stream function to voriticy   q = Tψq * ψ + F\nTqψ`inverse of Tψq   ψ = Tqψ*(q - F)\nf modified coriolis vector used in transforming stream function to vorticity\nJ_f3 coriolis contribution to Jacobian at 850hPa\ncH∇8 cH * 8-th order gradient for horizonatal diffusion\ncH∇8_3d cH * 8-th order gradient for horizonatal diffusion for 3d field\n∂k∂ϕ derivates of drag coefficients, pre computed for Ekman dissipation\n∂k∂μ\n∂k∂λ includes 1/cos^2ϕ (for Ekman dissipiation computation)\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.QG3Model-Tuple{QG3ModelParameters}","page":"Reference","title":"QG3.QG3Model","text":"QG3Model(p::QG3ModelParameters)\n\nRoutine that pre computes the QG3 Model and returns a QG3Model struct with all precomputed fields except for the forcing.\n\nThe pre-computation is always done on CPU due to scalar indexing being used, if a GPU is avaible the final result is then transferred to the GPU.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.QG3ModelParameters","page":"Reference","title":"QG3.QG3ModelParameters","text":"QG3ModelParameters{T}\n\nSaves all the parameters of the model\n\nFields\n\n* `L::Int`: number of SH number l, note that 0,...,l_max, so that L is l_max + 1\n* `M::Int`: # maximum number M values, M==2*L - 1 / 2*l_max + 1\n* `N_lats::Int`\n* `N_lons::Int`\n* `lats::AbstractArray{T,1}`\n* `θ::AbstractArray{T,1}` colatitudes = θ\n* `μ::AbstractArray{T,1}` sin(lats) == cos(colats)\n* `LS::AbstractArray{T,2}` Land see mask, on the same grid as lats and lons\n* `h::AbstractArray{T,2}`` orography, array on the same grid as lats and lons\n* `R1i::T` square inverse of Rossby radius 1 200-500hPa, default 1/(700km)^2\n* `R2i::T` square inverse of Rossby radius 2 500-800hPa, default 1/(450km)^2\n* `H0::T` scaling parameter for topography, default 9000m\n* `τRi::T` inverse of radiative time scale, default 1/(25d)\n* `τEi::T` inverse of drag time scale, default 1/(3d)\n* `cH::T` horizonatal diffusion coefficient\n* `α1::T` drag coefficient 1, default 0.5\n* `α2::T` drag coefficient 2, default 0.5\n* `a::T` Earth's radius  # WIP: some functions assume a=1\n* `Ω::T` Earth's angular speed for Coriolis # WIP: some functions assume Ω=1/2\n* `gridtype::String` either 'gaussian' or 'regular', 'gaussian' leads to all transform being done by somewhat naively implemented transforms, 'regular' uses FastTransforms.jl\n* `time_unit::T` unit so that t [normalized] = t [s] / time_unit, default = 1/4π\n* `distance_unit::T`, default Earth's radius\n* `ψ_unit::T`, derived from time_unit and distance_unit\n* `q_unit::T`, derived from time_unit and distance_unit\n\nOther constructors\n\nQG3ModelParameters(L::Int, lats::AbstractArray{T,1}, lons::AbstractArray{T,1}, LS::AbstractArray{T,2}, h::AbstractArray{T,2}, R1i::T, R2i::T, H0::T, τRi::T, τEi::T, τHi::T, α1::T, α2::T, a::T, Ω::T, gridtype::String, time_unit::T, distance_unit::T)\n\nDefault arguments for most parameters, so that\n\nQG3ModelParameters(L::Int, lats::AbstractArray{T,1}, lons::AbstractArray{T,1}, LS::AbstractArray{T,2}, h::AbstractArray{T,2})\n\nworks as well.\n\n\n\n\n\n","category":"type"},{"location":"ref/#QG3.D-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.D","text":"Dissipiation of all levels, 850hPa has additional Ekman dissipation\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.EK-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.EK","text":"Ekman dissipation\n\nEK = ∇(k∇ψ) = (∇k ∇ψ) + k Δψ  EK = 1/a^2cos^2ϕ ∂k/∂λ ∂ψ/∂λ + 1/a^2 ∂k/∂ϕ ∂ψ/∂ϕ + k Δψ   (a==1)\n\nm.∂k∂λ  includes 1/cos^2ϕ\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.H-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.H","text":"Horizontal diffusion, q' is anomolous pv (without coriolis) 2D Fields m.cH∇8 = m.p.cH * m.∇8\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.H-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.H","text":"Horizontal diffusion, q' is anomolous pv (without coriolis) 3D Fields\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.J-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.J","text":"Jacobian in 3D Field formulation (e.g. for GPU), the second term in the q derivatives is the contribution of the f(1+h/H_0) term to the 850hPa level.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.J-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.J","text":"Compute the Jacobian determinant from ψ and q in μ,λ coordinates, J = ∂ψ/∂x ∂q/∂y - ∂ψ/∂y ∂q/∂x = 1/a^2cosϕ ( - ∂ψ/∂λ ∂q/∂ϕ + ∂ψ/∂ϕ ∂q/∂λ) =  1/a^2 (- ∂ψ/∂λ ∂q/∂μ + ∂ψ/∂μ ∂q/∂λ)\n\nThe last term ∂ψ/∂λ accounts for the planetery vorticity, actually it is 2Ω ∂ψ/∂λ, but 2Ω == 1, (write q = q' + 2Ωμ to proof it)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.J3-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.J3","text":"For the Jacobian at 850hPa, q = q' + f(1+h/H0) = q' + f + f*h/H0, so that the thrid term has to be added.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.J_F-Union{Tuple{T}, Tuple{Any, Any, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.J_F","text":"Compute the Jacobian determinant from ψ and q in μ,λ coordinates without the planetary vorticity, as used in computing the eddy/transient forcing\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.QG3MM_adv-Tuple{Any, Any, Any}","page":"Reference","title":"QG3.QG3MM_adv","text":"QG3MM_adv(q, p, t)\n\nJust the Advection\n\ndq = - J(ψ,q)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.QG3MM_base-Tuple{Any, Any, Any}","page":"Reference","title":"QG3.QG3MM_base","text":"QG3MM_base(q, p, t)\n\nBase model used in the MM paper, with symmetrization around the equator\n\ndq = - J(ψ,q) - D(ψ,q) + S\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.QG3MM_gpu-Tuple{Any, Any, Any}","page":"Reference","title":"QG3.QG3MM_gpu","text":"QG3MM_gpu(q, p, t)\n\nBase model used in the MM paper, with symmetrization around the equator\n\ndq = - J(ψ,q) - D(ψ,q) + S\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoGrid_dθ-Union{Tuple{T}, Tuple{Any, QG3Model{T}}} where T","page":"Reference","title":"QG3.SHtoGrid_dθ","text":"derivative of input after θ (azimutal angle/colatitude) in SH, uses pre computed SH evaluations (dependend on the grid type)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoGrid_dμ-Union{Tuple{T}, Tuple{Any, QG3Model{T}}} where T","page":"Reference","title":"QG3.SHtoGrid_dμ","text":"derivative of input after μ = sinϕ in SH, uses pre computed SH evaluations\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoGrid_dφ-Union{Tuple{T}, Tuple{Any, QG3Model{T}}} where T","page":"Reference","title":"QG3.SHtoGrid_dφ","text":"derivative of input after φ (polar angle) or λ (longtitude) in SH to Grid, only for a single layer\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.SHtoSH_dφ-Union{Tuple{T}, Tuple{Any, QG3Model{T}}} where T","page":"Reference","title":"QG3.SHtoSH_dφ","text":"derivative of input after φ (polar angle/longtitude) in SH, output in SH\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.TR-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.TR","text":"Temperature relaxation of all levels\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.TR-Union{Tuple{T}, Tuple{QG3Model{T}, Any, Any, T}} where T<:Number","page":"Reference","title":"QG3.TR","text":"Temperature relaxation\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.add_to_level-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractMatrix{T}, Integer}} where T<:Number","page":"Reference","title":"QG3.add_to_level","text":"Differentiable and GPU compatible way of adding only to one of the levels of the model\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.change_msign!-Tuple{Any}","page":"Reference","title":"QG3.change_msign!","text":"change_msign!(A)\n\nChange the sign of the m in SH (FastTranforms.jl convention of storing them). This version swaps the columns inplace\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.change_msign-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}}} where T","page":"Reference","title":"QG3.change_msign","text":"change_msign(A)\n\nChange the sign of the m in SH. This version returns a view\n\nthere is currently a bug or at least missing feature in Zygote, the AD library, that stops views from always working flawlessly when a view is mixed with prior indexing of an array. We need a view for the derivative after φ to change the sign of m, so here is a differentiable variant of the SHtoSH_dφ function for the 2d field\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_GaussWeights-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T<:Number","page":"Reference","title":"QG3.compute_GaussWeights","text":"Pre-computes gaussian weights for Legendre Transform, also checks if we really have the correct gaussian latitudes\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_P-Union{Tuple{T}, Tuple{Integer, Integer, AbstractVector{T}}} where T<:Number","page":"Reference","title":"QG3.compute_P","text":"Pre-compute ass. Legendre Polynomials and dP/dx (derivative of ass. Legendre Polynomial) at the grid points and also the remainder of the Spherical Harmonics at the grid points using GSL\n\nm values are stored 0,-1,1,-2,2,-3,3,... (on CPU) m values are stored 0,1,2,3,4,5,6,7, ...l_max, 0 (nothing),-1, -2, -3, (on GPU)  (the second 0 is the Imanigary part / sin part of the fourier transform which is always identical to zero, it is kept here to have equal matrix sizes)\n\nso far only |m| is used, as I assume real SPH.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_S_Roads-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, QG3Model{T}}} where T<:Number","page":"Reference","title":"QG3.compute_S_Roads","text":"Pre-compute Forcing S data level,X,Y,t\n\nCompute the forcing according to Roads, this is outlined in the MM and Corti paper as well.\n\nThis uses an unfiltered version, in the Corti paper there is a filter. Maybe implement it as well\n\ndata, input data\nm, QG3Model Parameters and pre-computed fields\nkwargs\ndatasource, either 'qprime' (anomalous potential vorticity) or 'sf' (streamfunction)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_S_t_corti","page":"Reference","title":"QG3.compute_S_t_corti","text":"Pre-compute time-dependent Forcing S data level,X,Y,t\n\nLike in the Corti paper for the seasonal run this interpolates between two extremal forcings.\n\nNt_year: how many days does a year have / period length of the sinus\n\n\n\n\n\n","category":"function"},{"location":"ref/#QG3.compute_TR-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_TR","text":"Pre-compute array of temperature relaxation coefficients.\n\n(l=0, m=0)-coefficient is assigned zero. This results in this expansion coefficient beeing constant in the whole model.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_TR_matrix-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_TR_matrix","text":"Pre-compute matrices involved in the temperature relaxation in matrix form (for GPU / 3d fields)\n\nTR = TRMatrix * ψ  ∀ l ∈ [0,lmax]\n\nFor l=0 the matrix is set to be zero\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_acosϕi-Tuple{QG3ModelParameters}","page":"Reference","title":"QG3.compute_acosϕi","text":"Pre-compute (a*cos(ϕ))^-1 (latitude matrix)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_batched_TR_matrix-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_batched_TR_matrix","text":"compute_batched_TR_matrix\n\nprepares the TR = TRMatrix * ψ  ∀ l ∈ [0,lmax] matrix for batched multiply\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_batched_ψq_transform_matrices-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T<:Number","page":"Reference","title":"QG3.compute_batched_ψq_transform_matrices","text":"compute_batched_ψq_transform_matrices\n\nprepares the transform from q to ψ and back for a batched matrix vector multiply, see also (@ref)[compute_ψq_transform_matrices]\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_coriolis_vector_grid-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_coriolis_vector_grid","text":"Pre-compute a matrix with with the Coriolis factor\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_cosϕ-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T","page":"Reference","title":"QG3.compute_cosϕ","text":"Pre-compute cos(ϕ) (latitude) matrix\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_f_J3-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, AbstractArray{T, 3}}} where T<:Number","page":"Reference","title":"QG3.compute_f_J3","text":"Pre-compute the additional contribution of the Coriolis force to the 850hPa Jacobian component in GPU ready format, for the Jacobian at 850hPa, q = q' + f(1+h/H0) = q' + f + f*h/H0, so that the thrid term has to be added.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_k-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_k","text":"Pre-compute drag coefficient k in real grid space, double check with values from paper\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_Δ-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.compute_Δ","text":"Pre-compute the Laplacian in Spherical Harmonics, follows the matrix convention of FastTransforms.jl\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_ψq_transform_matrices-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T<:Number","page":"Reference","title":"QG3.compute_ψq_transform_matrices","text":"Pre-compute matrices involved in transforming vorticity to streamfunction and back\n\nq = Tψq * ψ + f ψ = Tqψ * (q - f) = Tψq^(-1) * (q - f)\n\nFor l=0 the matrix is singular. In the fortran code they set q to something which for me does not make sense. Here Tψq(l=0) is just 1, so that transforming back and forth recovers the correct ψ. This makes sense in my eyes because q is only ever used for its spatial derivatives, all of which are 0 for l=0.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.compute_∇8-Tuple{QG3ModelParameters}","page":"Reference","title":"QG3.compute_∇8","text":"\" Pre-compute the 8-th derivative in Spherical Harmonics\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.gpuoff-Tuple{}","page":"Reference","title":"QG3.gpuoff","text":"gpuon()\n\nManually toggle GPU use off\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.gpuon-Tuple{}","page":"Reference","title":"QG3.gpuon","text":"gpuon()\n\nManually toggle GPU use on (if available)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.grid-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, String}, Tuple{QG3ModelParameters{T}, String, Int64}} where T<:Number","page":"Reference","title":"QG3.grid","text":"grid(p::QG3ModelParameters{T})\n\nConvience constructor for the AbstractGridType based on the parameters set in p.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.isongpu-Union{Tuple{QG3Model{T}}, Tuple{T}} where T","page":"Reference","title":"QG3.isongpu","text":"isongpu(m::QG3Model{T})\n\nDetermines if the model was pre-computed to be used on GPU.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.lMatrix-Tuple{Integer, Integer}","page":"Reference","title":"QG3.lMatrix","text":"lMatrix(L, M; GPU=nothing)\n\nReturn l-Matrix of SH coefficients in convention of FastTransforms.jl. \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.level_index-Tuple{Any, Any}","page":"Reference","title":"QG3.level_index","text":"level_index(strings,lvls)\n\nHelper function for indexing netcdf files with many levels.\n\nstring, array with name of levels to be selected\nlvls, array with all levels\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.load_precomputed_data-Tuple{}","page":"Reference","title":"QG3.load_precomputed_data","text":"load_precomputed_data()\n\nLoads the precomputed data that is saved in the package. It is computed from ERA5 T21 u/v data. Returns in order\n\nS, qg3ppars, ψ_0, q_0\nForcing, Parameters, Streamfunction initial conditions, vorticity initial conditions\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.mMatrix-Union{Tuple{T}, Tuple{Integer, Integer}} where T<:Number","page":"Reference","title":"QG3.mMatrix","text":"mMatrix(L::Integer, M::Integer)\n\nPre-compute a matrix with (m) values of the SH matrix format of FastTransforms.jl, used for zonal derivative\n\nKwarg 'GPU', if given, overrides the automatic detection of wheather or not a GPU is avaible. \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.make3d-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"QG3.make3d","text":"make3d(A::AbstractArray{T,2})\n\nrepeats an array three times to turn it into (3 x size(A,1) x size(A,2)), for the fully matrix version of model.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.qprimetoψ-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T<:Number","page":"Reference","title":"QG3.qprimetoψ","text":"Convert the anomalous potential vorticity q' to streamfunction ψ\n\nThis version is slightly slower than the old one (as it not aware of the matrix being half full of zeroes), but it is non-mutating which makes it suitable for the automatic differentation.\n\nIt replaces the double loop over the coefficient matrix with a batched vector multiply. The advantage of that is that it is optimised for GPU, so it might actually be faster on the GPU than doing a manual loop.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.qtoψ-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T<:Number","page":"Reference","title":"QG3.qtoψ","text":"Convert the potential vorticity q to streamfunction ψ\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.reorder_SH_gpu-Union{Tuple{T}, Tuple{S}, Tuple{AbstractMatrix{S}, QG3ModelParameters{T}}} where {S, T}","page":"Reference","title":"QG3.reorder_SH_gpu","text":"Reorders the SH coefficient so that computations on GPU are more efficient, it also includes the truncation as the SH array has size Nlat x Nlon, however all entries outside of L x M are zeroes.\n\nOriginal order (FastTransforms.jl) columns by m : 0, -1, 1, -2, -2, ....\n\nNew order columns by m: 0, 1, 2, ... l_max, 0 (nothing), -1, -2, ..\n\n2d input assumes L x M matrix, (all fields in SH), also enlarges the matrix to include truncation (additional elements are zero) to Nlat x Nlons 3d input assumes Nlat (or 3) x L x M matrix (e.g. precomputed legendre polynomials), also enlarges the matrix to include truncation (additional elements are zero) to Nlat (or 3) x Nlats x Nlons\n\nIncase CUDA is not used, it just return the input.\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.sph_zero_spurious_modes!-Tuple{AbstractMatrix}","page":"Reference","title":"QG3.sph_zero_spurious_modes!","text":"Sets the unphysical numbers zero (usually only needed for FastTransforms.jl)\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.transform_SH","page":"Reference","title":"QG3.transform_SH","text":"transform_SH(data::AbstractArray{T,N}, t::GaussianGridtoSHTransform) \ntransform_SH(data::AbstractArray, m::QG3Model)\n\nTransforms data into the spherical harmonics domain. The coefficents are ordered in a matrix in coloumns of the m value. On CPU the convention of FastTransform.jl is used (0, -1, 1, -2, 2, ...), on GPU the convention (0, 1, 2, 3, ...., (nothing, -1, -2, -3, ...)). Watch out, in future proabaly this might be standardized. \n\n\n\n\n\n","category":"function"},{"location":"ref/#QG3.transform_grid","page":"Reference","title":"QG3.transform_grid","text":"transform_grid(data::AbstractArray{T,N}, t::SHtoGaussianGridTransform)\n\nTransforms data from the spherical harmonics domain to a Gaussian Grid. The coefficents are ordered in a matrix in coloumns of the m value. On CPU the convention of FastTransform.jl is used (0, -1, 1, -2, 2, ...), on GPU the convention (0, 1, 2, 3, ...., (nothing, -1, -2, -3, ...)). Watch out, in future proabaly this might be standardized. \n\ntransform_grid(data, m::QG3Model; varname=\"ψ\")\n\nIf varname ∈ [\"pv\",\"q\",\"vorticity\"] the [1,1] element is set to zero first, as this element is set to the streamfunction-[1,1] usually in the ψtoq routines.\n\n\n\n\n\n","category":"function"},{"location":"ref/#QG3.zeros_Grid-Union{Tuple{QG3Model{T}}, Tuple{T}} where T","page":"Reference","title":"QG3.zeros_Grid","text":"zeros_Grid(p::QG3Model{T})\n\nReturns a zero array in the dimensions of the grid. \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.zeros_SH-Union{Tuple{QG3Model{T}}, Tuple{T}} where T","page":"Reference","title":"QG3.zeros_SH","text":"zeros_SH(p::QG3Model{T})\n\nReturns a zero array in the dimensions of the SH. \n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.ψtoq-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T<:Number","page":"Reference","title":"QG3.ψtoq","text":"Convert the streamfunction ψ to the potential vorticity\n\n\n\n\n\n","category":"method"},{"location":"ref/#QG3.ψtoqprime-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T<:Number","page":"Reference","title":"QG3.ψtoqprime","text":"Convert the streamfunction ψ to (anomlous) potential vorticity q' in spherical harmonics basis\n\nThis version is slightly slower than the old one on CPU (as it not aware of the matrix being half full of zeroes), but it is non-mutating which makes it suitable for the automatic differentation.\n\nIt replaces the double loop over the coefficient matrix with a batched vector multiply. The advantage other besides it being non-mutating is that it is optimised for GPU, so it might actually be faster on the GPU than doing a manual loop.\n\n\n\n\n\n","category":"method"},{"location":"#QG3-Model","page":"Home","title":"QG3 Model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This module provides a Julia implementation of the Marshall, Molteni QG3 Model. It runs on GPUs and is differentiable (tested only with Zygote).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The model is solved with a pseudo-spectral approach. Currently there is a naive implemention of Real Spherical Harmonics with transforms defined for a Gaussian Grid. There are bindings to FastTransforms.jl for a regular grid as well, however this is experimental and suffers from aliasing problems when integrating the equation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"So far this documentation is not yet fully fledged out. It just provides the docstrings and some very basic how-to.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are example scripts in the examples folder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Install e.g. via ]add https://gitlab.pik-potsdam.de/maxgelbr/qg3.jl.git and test the installation with ]test QG3","category":"page"},{"location":"","page":"Home","title":"Home","text":"The repository includes pre-computed forcing and initial conditions to run the model but no proper dataset in order to save space.","category":"page"},{"location":"#The-Model","page":"Home","title":"The Model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Details about the model can be read up in \"Towards a Dynamical Understanding of Planetary-Scale Flow Regimes\", Marshall, Molteni, Journal of Atmsopheric Sciences, 1992.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Its governing equation for the quasigeostrophic vorticity q_i in three equipressure levels (200, 500, 800 hPa) are given be","category":"page"},{"location":"","page":"Home","title":"Home","text":"dotq_i = -J(psi_i q_i) - D(psi_i q_i) + S \nvecq = T_psi q vecpsi","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the voriticy q and streamfunction psi are related by a linear operator (comprising the Laplacian and temperature relaxation), J is the Jacobian / advection term, D the dissipation and S a forcing computed from data.","category":"page"},{"location":"#GPU-and-CPU","page":"Home","title":"GPU and CPU","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently there are two different implementations, one that is optimised for CPU (the \"2D version\") and one that is optimised for GPU (the \"3D version\"). The GPU version can also run on CPU but not the other way around.","category":"page"},{"location":"#GPU-Version","page":"Home","title":"GPU Version","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The GPU version is fully vectorized, without scalar indexing. All needed functions work on the 3d (level, lat, lon) / (level, il, m) field. The full problem definition thus is just simply","category":"page"},{"location":"","page":"Home","title":"Home","text":"function QG3MM_gpu(q, m, t)\n    p, S = m # parameters, forcing vector\n\n    ψ = qprimetoψ(p, q)\n    return - J(ψ, q, p) - D(ψ, q, p) + S\nend","category":"page"},{"location":"#CPU-Version","page":"Home","title":"CPU Version","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The CPU version works on 2d fields (lat, lon) / (il, m), on CPUs this is currently a little faster than using the GPU/3D version on CPU. In other words: the GPU version could probably still be optimized further. The problem definition follows as","category":"page"},{"location":"","page":"Home","title":"Home","text":"function QG3MM_base(q, m, t)\n    p, S = m # parameters, forcing vector\n\n    ψ = qprimetoψ(p, q)\n    return cat(\n    reshape(- J(ψ[1,:,:], q[1,:,:], p) .- D1(ψ, q, p) .+ S[1,:,:], (1, p.p.L, p.p.M)),\n    reshape(- J(ψ[2,:,:], q[2,:,:], p) .- D2(ψ, q, p) .+ S[2,:,:], (1, p.p.L, p.p.M)),\n    reshape(- J3(ψ[3,:,:], q[3,:,:], p) .- D3(ψ, q, p) .+ S[3,:,:], (1, p.p.L, p.p.M)),\n    dims=1)\nend","category":"page"},{"location":"#Transforms","page":"Home","title":"Transforms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Throughout the model real spherical harmonics are used. The transform is handled either by naive SH transform (FFT + Gauss-Legendre Quadrature) or the FastTransforms.jl library and is pre-computed. The FastTransforms.jl is currently invoking aliasing problems and not working for the full model. SHs are handled in the matrix convention that FastTransforms.jl uses: columns by m-value: 0, -1, 1, -2, 2, ..., rows l in ascending order. This is for the naive SH transform definately not the fasted way of storing the coefficients as an additonal allocating reordering needs to be done for every transform. Therefore the coefficient matrix convention is different on GPU, where the columns are ordered 0, 1, 2, .... lmax, 0, -1, -2, -3, .. . Transforms are called with [`transformSH](@ref) and [transform_grid`](@ref).","category":"page"}]
}
