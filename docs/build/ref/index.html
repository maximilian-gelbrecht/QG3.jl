<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · QG3</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QG3</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/ref.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="QG3.AbstractGridType" href="#QG3.AbstractGridType"><code>QG3.AbstractGridType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGridType{T, onGPU}</code></pre><p>Abstract type for grids. The grids save information about the transform from the spatial to spectral grid, e.g. pre-computed Legendre Polynomials</p><p>Required fields: </p><ul><li><code>GtoSH</code></li><li><code>SHtoG</code></li><li><code>dμ</code></li><li><code>dλ</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.AbstractSHTransform" href="#QG3.AbstractSHTransform"><code>QG3.AbstractSHTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractSHTransform{onGPU}</code></pre><p>Required fields for all subtypes: </p><ul><li>outputsize</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.AbstractμDerivative" href="#QG3.AbstractμDerivative"><code>QG3.AbstractμDerivative</code></a> — <span class="docstring-category">Type</span></header><section><div><p>abstract type AbstractμDerivative{onGPU} &lt; AbstractDerivative{onGPU} </p><p>Required fields: </p><ul><li><code>msinθ</code>: To change between μ and latitude derivative (-sin(colats))</li><li><code>msinθ_3d</code>: To change between μ and latitude derivative (-sin(colats))</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.ContinousTimeForcing" href="#QG3.ContinousTimeForcing"><code>QG3.ContinousTimeForcing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeForcing</code></pre><p>Time-dependent Forcing</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.Derivative_dλ" href="#QG3.Derivative_dλ"><code>QG3.Derivative_dλ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Derivative_dλ</code></pre><p>Pre-computes Derivatives by longitude. Uses the SH relation, is therefore independ from the grid.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.GaussianGrid" href="#QG3.GaussianGrid"><code>QG3.GaussianGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"> GaussianGrid{T, onGPU} &lt;: AbstractGridType{T, onGPU}</code></pre><p>Struct for the transforms and derivates of a Gaussian Grid</p><p><strong>Fields:</strong></p><ul><li><code>GtoSH::GaussianGridtoSHTransform</code></li><li><code>SHtoG::GaussianSHtoGridTransform</code></li><li><code>dμ::GaussianGrid_dμ</code></li><li><code>dλ::Derivative_dλ</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.GaussianGrid_dμ" href="#QG3.GaussianGrid_dμ"><code>QG3.GaussianGrid_dμ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussianGrid_dμ(p::QG3ModelParameters{T}, N_level::Int=3)</code></pre><p>Pre-computes Pseudo-spectral approach to computing derivatives with repsect to μ = sin(lats). Derivatives are called with following the naming scheme: &quot;Domain1Input&quot;to&quot;Domain2Output&quot;_d&quot;derivativeby&quot;</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.GaussianGridtoSHTransform" href="#QG3.GaussianGridtoSHTransform"><code>QG3.GaussianGridtoSHTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><p>GaussianGridtoSHTransform(p::QG3ModelParameters{T}, N_level::Int=3)</p><p>Returns transform struct, that can be used with <code>transform_SH</code>. This is one is for a Gaussian Grid.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.QG3Model" href="#QG3.QG3Model"><code>QG3.QG3Model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QG3Model{T}</code></pre><p>Holds all parameter and grid information, plus additional pre-computed fields that save computation time during model integration. All these parameter are seen as constants and not trainable. It should be computed on CPU, if you are on GPU use <code>CUDA.@allowscalar QG3Model(...)</code>.</p><p><strong>Fields</strong></p><ul><li><code>p::QG3ModelParameters{T}</code> Parameters of the model</li><li><code>g::AbstractGridType{T}</code> Grid type with pre-computed plans or Legendre polynomals and co.</li><li><code>k::AbstractArray{T,2}</code> Array, drag coefficient pre-computed from orography and land-sea mask</li><li><code>TRcoeffs::AbstractArray{T,3}</code> Array of Temperature relaxation coefficients (2d version)</li><li><code>TR_matrix</code> Matrix for temperature relaxation (3d version)</li><li><code>cosϕ::AbstractArray{T,2}</code> cos(latitude) pre computed</li><li><code>acosϕi::AbstractArray{T,2}</code> inverse of a*cos(latitude) pre computed</li><li><code>Δ::AbstractArray{T,2}</code> # laplace operator in spherical harmonical coordinates</li><li><code>Tψq</code> matrix used for transforming stream function to voriticy   q = Tψq * ψ + F</li><li><code>Tqψ</code>`inverse of Tψq   ψ = Tqψ*(q - F)</li><li><code>f</code> modified coriolis vector used in transforming stream function to vorticity</li><li><code>J_f3</code> coriolis contribution to Jacobian at 850hPa</li><li><code>cH∇8</code> cH * 8-th order gradient for horizonatal diffusion</li><li><code>cH∇8_3d</code> cH * 8-th order gradient for horizonatal diffusion for 3d field</li><li><code>∂k∂ϕ</code> derivates of drag coefficients, pre computed for Ekman dissipation</li><li><code>∂k∂μ</code></li><li><code>∂k∂λ</code> includes 1/cos^2ϕ (for Ekman dissipiation computation)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.QG3Model-Tuple{QG3ModelParameters}" href="#QG3.QG3Model-Tuple{QG3ModelParameters}"><code>QG3.QG3Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QG3Model(p::QG3ModelParameters)</code></pre><p>Routine that pre computes the QG3 Model and returns a QG3Model struct with all precomputed fields except for the forcing.</p><p>The pre-computation is always done on CPU due to scalar indexing being used, if a GPU is avaible the final result is then transferred to the GPU.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.QG3ModelParameters" href="#QG3.QG3ModelParameters"><code>QG3.QG3ModelParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QG3ModelParameters{T}</code></pre><p>Saves all the parameters of the model</p><p><strong>Fields</strong></p><pre><code class="nohighlight hljs">* `L::Int`: number of SH number l, note that 0,...,l_max, so that L is l_max + 1
* `M::Int`: # maximum number M values, M==2*L - 1 / 2*l_max + 1
* `N_lats::Int`
* `N_lons::Int`
* `lats::AbstractArray{T,1}`
* `θ::AbstractArray{T,1}` colatitudes = θ
* `μ::AbstractArray{T,1}` sin(lats) == cos(colats)
* `LS::AbstractArray{T,2}` Land see mask, on the same grid as lats and lons
* `h::AbstractArray{T,2}`` orography, array on the same grid as lats and lons
* `R1i::T` square inverse of Rossby radius 1 200-500hPa, default 1/(700km)^2
* `R2i::T` square inverse of Rossby radius 2 500-800hPa, default 1/(450km)^2
* `H0::T` scaling parameter for topography, default 9000m
* `τRi::T` inverse of radiative time scale, default 1/(25d)
* `τEi::T` inverse of drag time scale, default 1/(3d)
* `cH::T` horizonatal diffusion coefficient
* `α1::T` drag coefficient 1, default 0.5
* `α2::T` drag coefficient 2, default 0.5
* `a::T` Earth&#39;s radius  # WIP: some functions assume a=1
* `Ω::T` Earth&#39;s angular speed for Coriolis # WIP: some functions assume Ω=1/2
* `gridtype::String` either &#39;gaussian&#39; or &#39;regular&#39;, &#39;gaussian&#39; leads to all transform being done by somewhat naively implemented transforms, &#39;regular&#39; uses FastTransforms.jl
* `time_unit::T` unit so that t [normalized] = t [s] / time_unit, default = 1/4π
* `distance_unit::T`, default Earth&#39;s radius
* `ψ_unit::T`, derived from time_unit and distance_unit
* `q_unit::T`, derived from time_unit and distance_unit</code></pre><p><strong>Other constructors</strong></p><pre><code class="nohighlight hljs">QG3ModelParameters(L::Int, lats::AbstractArray{T,1}, lons::AbstractArray{T,1}, LS::AbstractArray{T,2}, h::AbstractArray{T,2}, R1i::T, R2i::T, H0::T, τRi::T, τEi::T, τHi::T, α1::T, α2::T, a::T, Ω::T, gridtype::String, time_unit::T, distance_unit::T)</code></pre><p>Default arguments for most parameters, so that</p><pre><code class="nohighlight hljs">QG3ModelParameters(L::Int, lats::AbstractArray{T,1}, lons::AbstractArray{T,1}, LS::AbstractArray{T,2}, h::AbstractArray{T,2})</code></pre><p>works as well.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.D-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}, QG3Model{T}}} where T&lt;:Number" href="#QG3.D-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}, QG3Model{T}}} where T&lt;:Number"><code>QG3.D</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Dissipiation of all levels, 850hPa has additional Ekman dissipation</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.EK-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T&lt;:Number" href="#QG3.EK-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T&lt;:Number"><code>QG3.EK</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Ekman dissipation</p><p>EK = ∇(k∇ψ) = (∇k ∇ψ) + k Δψ  EK = 1/a^2cos^2ϕ ∂k/∂λ ∂ψ/∂λ + 1/a^2 ∂k/∂ϕ ∂ψ/∂ϕ + k Δψ   (a==1)</p><p>m.∂k∂λ  includes 1/cos^2ϕ</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.H-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, QG3Model{T}}} where T&lt;:Number" href="#QG3.H-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, QG3Model{T}}} where T&lt;:Number"><code>QG3.H</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Horizontal diffusion, q&#39; is anomolous pv (without coriolis) 2D Fields m.cH∇8 = m.p.cH * m.∇8</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.H-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T}}} where T&lt;:Number" href="#QG3.H-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T}}} where T&lt;:Number"><code>QG3.H</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Horizontal diffusion, q&#39; is anomolous pv (without coriolis) 3D Fields</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.J-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}, QG3Model{T}}} where T&lt;:Number" href="#QG3.J-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}, QG3Model{T}}} where T&lt;:Number"><code>QG3.J</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Jacobian in 3D Field formulation (e.g. for GPU), the second term in the q derivatives is the contribution of the f(1+h/H_0) term to the 850hPa level.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.J-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, QG3Model{T}}} where T&lt;:Number" href="#QG3.J-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, QG3Model{T}}} where T&lt;:Number"><code>QG3.J</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the Jacobian determinant from ψ and q in μ,λ coordinates, J = ∂ψ/∂x ∂q/∂y - ∂ψ/∂y ∂q/∂x = 1/a^2cosϕ ( - ∂ψ/∂λ ∂q/∂ϕ + ∂ψ/∂ϕ ∂q/∂λ) =  1/a^2 (- ∂ψ/∂λ ∂q/∂μ + ∂ψ/∂μ ∂q/∂λ)</p><p>The last term ∂ψ/∂λ accounts for the planetery vorticity, actually it is 2Ω ∂ψ/∂λ, but 2Ω == 1, (write q = q&#39; + 2Ωμ to proof it)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.J3-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, QG3Model{T}}} where T&lt;:Number" href="#QG3.J3-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, QG3Model{T}}} where T&lt;:Number"><code>QG3.J3</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For the Jacobian at 850hPa, q = q&#39; + f(1+h/H<em>0) = q&#39; + f + f*h/H</em>0, so that the thrid term has to be added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.J_F-Union{Tuple{T}, Tuple{Any, Any, QG3Model{T}}} where T&lt;:Number" href="#QG3.J_F-Union{Tuple{T}, Tuple{Any, Any, QG3Model{T}}} where T&lt;:Number"><code>QG3.J_F</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the Jacobian determinant from ψ and q in μ,λ coordinates without the planetary vorticity, as used in computing the eddy/transient forcing</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.QG3MM_adv-Tuple{Any, Any, Any}" href="#QG3.QG3MM_adv-Tuple{Any, Any, Any}"><code>QG3.QG3MM_adv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QG3MM_adv(q, p, t)</code></pre><p>Just the Advection</p><p>dq = - J(ψ,q)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.QG3MM_base-Tuple{Any, Any, Any}" href="#QG3.QG3MM_base-Tuple{Any, Any, Any}"><code>QG3.QG3MM_base</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QG3MM_base(q, p, t)</code></pre><p>Base model used in the MM paper, with symmetrization around the equator</p><p>dq = - J(ψ,q) - D(ψ,q) + S</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.QG3MM_gpu-Tuple{Any, Any, Any}" href="#QG3.QG3MM_gpu-Tuple{Any, Any, Any}"><code>QG3.QG3MM_gpu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QG3MM_gpu(q, p, t)</code></pre><p>Base model used in the MM paper, with symmetrization around the equator</p><p>dq = - J(ψ,q) - D(ψ,q) + S</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.SHtoGrid_dθ-Union{Tuple{T}, Tuple{Any, QG3Model{T}}} where T" href="#QG3.SHtoGrid_dθ-Union{Tuple{T}, Tuple{Any, QG3Model{T}}} where T"><code>QG3.SHtoGrid_dθ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>derivative of input after θ (azimutal angle/colatitude) in SH, uses pre computed SH evaluations (dependend on the grid type)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.SHtoGrid_dμ-Union{Tuple{T}, Tuple{Any, QG3Model{T}}} where T" href="#QG3.SHtoGrid_dμ-Union{Tuple{T}, Tuple{Any, QG3Model{T}}} where T"><code>QG3.SHtoGrid_dμ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>derivative of input after μ = sinϕ in SH, uses pre computed SH evaluations</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.SHtoGrid_dφ-Union{Tuple{T}, Tuple{Any, QG3Model{T}}} where T" href="#QG3.SHtoGrid_dφ-Union{Tuple{T}, Tuple{Any, QG3Model{T}}} where T"><code>QG3.SHtoGrid_dφ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>derivative of input after φ (polar angle) or λ (longtitude) in SH to Grid, only for a single layer</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.SHtoSH_dφ-Union{Tuple{T}, Tuple{Any, QG3Model{T}}} where T" href="#QG3.SHtoSH_dφ-Union{Tuple{T}, Tuple{Any, QG3Model{T}}} where T"><code>QG3.SHtoSH_dφ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>derivative of input after φ (polar angle/longtitude) in SH, output in SH</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.TR-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T}}} where T&lt;:Number" href="#QG3.TR-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T}}} where T&lt;:Number"><code>QG3.TR</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Temperature relaxation of all levels</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.TR-Union{Tuple{T}, Tuple{QG3Model{T}, Any, Any, T}} where T&lt;:Number" href="#QG3.TR-Union{Tuple{T}, Tuple{QG3Model{T}, Any, Any, T}} where T&lt;:Number"><code>QG3.TR</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Temperature relaxation</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.add_to_level-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractMatrix{T}, Integer}} where T&lt;:Number" href="#QG3.add_to_level-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractMatrix{T}, Integer}} where T&lt;:Number"><code>QG3.add_to_level</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Differentiable and GPU compatible way of adding only to one of the levels of the model</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.change_msign!-Tuple{Any}" href="#QG3.change_msign!-Tuple{Any}"><code>QG3.change_msign!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_msign!(A)</code></pre><p>Change the sign of the m in SH (FastTranforms.jl convention of storing them). This version swaps the columns inplace</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.change_msign-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}}} where T" href="#QG3.change_msign-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}}} where T"><code>QG3.change_msign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_msign(A)</code></pre><p>Change the sign of the m in SH. This version returns a view</p><p>there is currently a bug or at least missing feature in Zygote, the AD library, that stops views from always working flawlessly when a view is mixed with prior indexing of an array. We need a view for the derivative after φ to change the sign of m, so here is a differentiable variant of the SHtoSH_dφ function for the 2d field</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_GaussWeights-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T&lt;:Number" href="#QG3.compute_GaussWeights-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T&lt;:Number"><code>QG3.compute_GaussWeights</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-computes gaussian weights for Legendre Transform, also checks if we really have the correct gaussian latitudes</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_P-Union{Tuple{T}, Tuple{Integer, Integer, AbstractVector{T}}} where T&lt;:Number" href="#QG3.compute_P-Union{Tuple{T}, Tuple{Integer, Integer, AbstractVector{T}}} where T&lt;:Number"><code>QG3.compute_P</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute ass. Legendre Polynomials and dP/dx (derivative of ass. Legendre Polynomial) at the grid points and also the remainder of the Spherical Harmonics at the grid points using GSL</p><p>m values are stored 0,-1,1,-2,2,-3,3,... (on CPU) m values are stored 0,1,2,3,4,5,6,7, ...l_max, 0 (nothing),-1, -2, -3, (on GPU)  (the second 0 is the Imanigary part / sin part of the fourier transform which is always identical to zero, it is kept here to have equal matrix sizes)</p><p><strong>so far only |m| is used, as I assume real SPH.</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_S_Roads-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, QG3Model{T}}} where T&lt;:Number" href="#QG3.compute_S_Roads-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, QG3Model{T}}} where T&lt;:Number"><code>QG3.compute_S_Roads</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute Forcing S data level,X,Y,t</p><p>Compute the forcing according to Roads, this is outlined in the MM and Corti paper as well.</p><p>This uses an unfiltered version, in the Corti paper there is a filter. Maybe implement it as well</p><ul><li>data, input data</li><li>m, QG3Model Parameters and pre-computed fields</li><li>kwargs<ul><li>datasource, either &#39;qprime&#39; (anomalous potential vorticity) or &#39;sf&#39; (streamfunction)</li></ul></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_S_t_corti" href="#QG3.compute_S_t_corti"><code>QG3.compute_S_t_corti</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Pre-compute time-dependent Forcing S data level,X,Y,t</p><p>Like in the Corti paper for the seasonal run this interpolates between two extremal forcings.</p><ul><li>Nt_year: how many days does a year have / period length of the sinus</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_TR-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number" href="#QG3.compute_TR-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number"><code>QG3.compute_TR</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute array of temperature relaxation coefficients.</p><p>(l=0, m=0)-coefficient is assigned zero. This results in this expansion coefficient beeing constant in the whole model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_TR_matrix-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number" href="#QG3.compute_TR_matrix-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number"><code>QG3.compute_TR_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute matrices involved in the temperature relaxation in matrix form (for GPU / 3d fields)</p><p>TR = TR<em>Matrix * ψ  ∀ l ∈ [0,l</em>max]</p><p><strong>For l=0 the matrix is set to be zero</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_acosϕi-Tuple{QG3ModelParameters}" href="#QG3.compute_acosϕi-Tuple{QG3ModelParameters}"><code>QG3.compute_acosϕi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute (a*cos(ϕ))^-1 (latitude matrix)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_batched_TR_matrix-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number" href="#QG3.compute_batched_TR_matrix-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number"><code>QG3.compute_batched_TR_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_batched_TR_matrix</code></pre><p>prepares the TR = TR<em>Matrix * ψ  ∀ l ∈ [0,l</em>max] matrix for batched multiply</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_batched_ψq_transform_matrices-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T&lt;:Number" href="#QG3.compute_batched_ψq_transform_matrices-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T&lt;:Number"><code>QG3.compute_batched_ψq_transform_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_batched_ψq_transform_matrices</code></pre><p>prepares the transform from q to ψ and back for a batched matrix vector multiply, see also (@ref)[<code>compute_ψq_transform_matrices</code>]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_coriolis_vector_grid-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number" href="#QG3.compute_coriolis_vector_grid-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number"><code>QG3.compute_coriolis_vector_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute a matrix with with the Coriolis factor</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_cosϕ-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T" href="#QG3.compute_cosϕ-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T"><code>QG3.compute_cosϕ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute cos(ϕ) (latitude) matrix</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_f_J3-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, AbstractArray{T, 3}}} where T&lt;:Number" href="#QG3.compute_f_J3-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, AbstractArray{T, 3}}} where T&lt;:Number"><code>QG3.compute_f_J3</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute the additional contribution of the Coriolis force to the 850hPa Jacobian component in GPU ready format, for the Jacobian at 850hPa, q = q&#39; + f(1+h/H<em>0) = q&#39; + f + f*h/H</em>0, so that the thrid term has to be added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_k-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number" href="#QG3.compute_k-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number"><code>QG3.compute_k</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute drag coefficient k in real grid space, double check with values from paper</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_Δ-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number" href="#QG3.compute_Δ-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number"><code>QG3.compute_Δ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute the Laplacian in Spherical Harmonics, follows the matrix convention of FastTransforms.jl</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_ψq_transform_matrices-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T&lt;:Number" href="#QG3.compute_ψq_transform_matrices-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T&lt;:Number"><code>QG3.compute_ψq_transform_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute matrices involved in transforming vorticity to streamfunction and back</p><p>q = Tψq * ψ + f ψ = Tqψ * (q - f) = Tψq^(-1) * (q - f)</p><p><strong>For l=0 the matrix is singular. In the fortran code they set q to something which for me does not make sense. Here Tψq(l=0) is just 1, so that transforming back and forth recovers the correct ψ. This makes sense in my eyes because q is only ever used for its spatial derivatives, all of which are 0 for l=0.</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_∇8-Tuple{QG3ModelParameters}" href="#QG3.compute_∇8-Tuple{QG3ModelParameters}"><code>QG3.compute_∇8</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot; Pre-compute the 8-th derivative in Spherical Harmonics</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.gpuoff-Tuple{}" href="#QG3.gpuoff-Tuple{}"><code>QG3.gpuoff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gpuon()</code></pre><p>Manually toggle GPU use off</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.gpuon-Tuple{}" href="#QG3.gpuon-Tuple{}"><code>QG3.gpuon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gpuon()</code></pre><p>Manually toggle GPU use on (if available)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.grid-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, String}, Tuple{QG3ModelParameters{T}, String, Int64}} where T&lt;:Number" href="#QG3.grid-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, String}, Tuple{QG3ModelParameters{T}, String, Int64}} where T&lt;:Number"><code>QG3.grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grid(p::QG3ModelParameters{T})</code></pre><p>Convience constructor for the <a href="#QG3.AbstractGridType"><code>AbstractGridType</code></a> based on the parameters set in <code>p</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.isongpu-Union{Tuple{QG3Model{T}}, Tuple{T}} where T" href="#QG3.isongpu-Union{Tuple{QG3Model{T}}, Tuple{T}} where T"><code>QG3.isongpu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isongpu(m::QG3Model{T})</code></pre><p>Determines if the model was pre-computed to be used on GPU.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.lMatrix-Tuple{Integer, Integer}" href="#QG3.lMatrix-Tuple{Integer, Integer}"><code>QG3.lMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lMatrix(L, M; GPU=nothing)</code></pre><p>Return l-Matrix of SH coefficients in convention of FastTransforms.jl. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.level_index-Tuple{Any, Any}" href="#QG3.level_index-Tuple{Any, Any}"><code>QG3.level_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">level_index(strings,lvls)</code></pre><p>Helper function for indexing netcdf files with many levels.</p><ul><li>string, array with name of levels to be selected</li><li>lvls, array with all levels</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.load_precomputed_data-Tuple{}" href="#QG3.load_precomputed_data-Tuple{}"><code>QG3.load_precomputed_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_precomputed_data()</code></pre><p>Loads the precomputed data that is saved in the package. It is computed from ERA5 T21 u/v data. Returns in order</p><ul><li><code>S</code>, <code>qg3ppars</code>, <code>ψ_0</code>, <code>q_0</code></li><li>Forcing, Parameters, Streamfunction initial conditions, vorticity initial conditions</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.mMatrix-Union{Tuple{T}, Tuple{Integer, Integer}} where T&lt;:Number" href="#QG3.mMatrix-Union{Tuple{T}, Tuple{Integer, Integer}} where T&lt;:Number"><code>QG3.mMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mMatrix(L::Integer, M::Integer)</code></pre><p>Pre-compute a matrix with (m) values of the SH matrix format of FastTransforms.jl, used for zonal derivative</p><p>Kwarg &#39;GPU&#39;, if given, overrides the automatic detection of wheather or not a GPU is avaible. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.make3d-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number" href="#QG3.make3d-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number"><code>QG3.make3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make3d(A::AbstractArray{T,2})

repeats an array three times to turn it into (3 x size(A,1) x size(A,2)), for the fully matrix version of model.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.qprimetoψ-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number" href="#QG3.qprimetoψ-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number"><code>QG3.qprimetoψ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert the anomalous potential vorticity q&#39; to streamfunction ψ</p><p>This version is slightly slower than the old one (as it not aware of the matrix being half full of zeroes), but it is non-mutating which makes it suitable for the automatic differentation.</p><p>It replaces the double loop over the coefficient matrix with a batched vector multiply. The advantage of that is that it is optimised for GPU, so it might actually be faster on the GPU than doing a manual loop.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.qtoψ-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number" href="#QG3.qtoψ-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number"><code>QG3.qtoψ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert the potential vorticity q to streamfunction ψ</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.reorder_SH_gpu-Union{Tuple{T}, Tuple{S}, Tuple{AbstractMatrix{S}, QG3ModelParameters{T}}} where {S, T}" href="#QG3.reorder_SH_gpu-Union{Tuple{T}, Tuple{S}, Tuple{AbstractMatrix{S}, QG3ModelParameters{T}}} where {S, T}"><code>QG3.reorder_SH_gpu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reorders the SH coefficient so that computations on GPU are more efficient, it also includes the truncation as the SH array has size N<em>lat x N</em>lon, however all entries outside of L x M are zeroes.</p><p>Original order (FastTransforms.jl) columns by m : 0, -1, 1, -2, -2, ....</p><p>New order columns by m: 0, 1, 2, ... l_max, 0 (nothing), -1, -2, ..</p><p>2d input assumes L x M matrix, (all fields in SH), also enlarges the matrix to include truncation (additional elements are zero) to N<em>lat x N</em>lons 3d input assumes N<em>lat (or 3) x L x M matrix (e.g. precomputed legendre polynomials), also enlarges the matrix to include truncation (additional elements are zero) to N</em>lat (or 3) x N<em>lats x N</em>lons</p><p>Incase CUDA is not used, it just return the input.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.sph_zero_spurious_modes!-Tuple{AbstractMatrix}" href="#QG3.sph_zero_spurious_modes!-Tuple{AbstractMatrix}"><code>QG3.sph_zero_spurious_modes!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sets the unphysical numbers zero (usually only needed for FastTransforms.jl)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.transform_SH" href="#QG3.transform_SH"><code>QG3.transform_SH</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_SH(data::AbstractArray{T,N}, t::GaussianGridtoSHTransform) 
transform_SH(data::AbstractArray, m::QG3Model)</code></pre><p>Transforms <code>data</code> into the spherical harmonics domain. The coefficents are ordered in a matrix in coloumns of the m value. On CPU the convention of FastTransform.jl is used (0, -1, 1, -2, 2, ...), on GPU the convention (0, 1, 2, 3, ...., (nothing, -1, -2, -3, ...)). Watch out, in future proabaly this might be standardized. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.transform_grid" href="#QG3.transform_grid"><code>QG3.transform_grid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_grid(data::AbstractArray{T,N}, t::SHtoGaussianGridTransform)</code></pre><p>Transforms <code>data</code> from the spherical harmonics domain to a Gaussian Grid. The coefficents are ordered in a matrix in coloumns of the m value. On CPU the convention of FastTransform.jl is used (0, -1, 1, -2, 2, ...), on GPU the convention (0, 1, 2, 3, ...., (nothing, -1, -2, -3, ...)). Watch out, in future proabaly this might be standardized. </p><pre><code class="nohighlight hljs">transform_grid(data, m::QG3Model; varname=&quot;ψ&quot;)</code></pre><p>If varname ∈ [&quot;pv&quot;,&quot;q&quot;,&quot;vorticity&quot;] the [1,1] element is set to zero first, as this element is set to the streamfunction-[1,1] usually in the ψtoq routines.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.zeros_Grid-Union{Tuple{QG3Model{T}}, Tuple{T}} where T" href="#QG3.zeros_Grid-Union{Tuple{QG3Model{T}}, Tuple{T}} where T"><code>QG3.zeros_Grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zeros_Grid(p::QG3Model{T})</code></pre><p>Returns a zero array in the dimensions of the grid. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.zeros_SH-Union{Tuple{QG3Model{T}}, Tuple{T}} where T" href="#QG3.zeros_SH-Union{Tuple{QG3Model{T}}, Tuple{T}} where T"><code>QG3.zeros_SH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zeros_SH(p::QG3Model{T})</code></pre><p>Returns a zero array in the dimensions of the SH. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.ψtoq-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number" href="#QG3.ψtoq-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number"><code>QG3.ψtoq</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert the streamfunction ψ to the potential vorticity</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.ψtoqprime-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number" href="#QG3.ψtoqprime-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number"><code>QG3.ψtoqprime</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert the streamfunction ψ to (anomlous) potential vorticity q&#39; in spherical harmonics basis</p><p>This version is slightly slower than the old one on CPU (as it not aware of the matrix being half full of zeroes), but it is non-mutating which makes it suitable for the automatic differentation.</p><p>It replaces the double loop over the coefficient matrix with a batched vector multiply. The advantage other besides it being non-mutating is that it is optimised for GPU, so it might actually be faster on the GPU than doing a manual loop.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.14 on <span class="colophon-date" title="Wednesday 2 March 2022 20:02">Wednesday 2 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
