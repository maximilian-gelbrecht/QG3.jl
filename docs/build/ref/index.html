<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · QG3</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">QG3</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/ref.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-binding" id="QG3.AbstractGridType" href="#QG3.AbstractGridType"><code>QG3.AbstractGridType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractGridType{T, onGPU}</code></pre><p>Abstract type for grids. The grids save information about the transform from the spatial to spectral grid, e.g. pre-computed Legendre Polynomials</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.ContinousTimeForcing" href="#QG3.ContinousTimeForcing"><code>QG3.ContinousTimeForcing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TimeForcing</code></pre><p>Time-dependent Forcing</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.QG3Model" href="#QG3.QG3Model"><code>QG3.QG3Model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QG3Model{T}</code></pre><p>Holds all parameter and grid information, plus additional pre-computed fields that save computation time during model integration</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.QG3Model-Tuple{QG3ModelParameters}" href="#QG3.QG3Model-Tuple{QG3ModelParameters}"><code>QG3.QG3Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QG3Model(p::QG3ModelParameters)</code></pre><p>Routine that pre computes the QG3 Model and returns a QG3Model struct with all precomputed fields except for the forcing.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.QG3ModelParameters" href="#QG3.QG3ModelParameters"><code>QG3.QG3ModelParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QG3ModelParameters{T}</code></pre><p>Saves all the parameters of the model</p><p><strong>Fields</strong></p><pre><code class="language-none">* `L::Int`: number of SH number l, note that 0,...,l_max, so that L is l_max + 1
* `M::Int`: # maximum number M values, M==2*L - 1 / 2*l_max + 1
* `N_lats::Int`
* `N_lons::Int`
* `lats::AbstractArray{T,1}`
* `colats::AbstractArray{T,1}` colatitudes = θ
* `μ::AbstractArray{T,1}` sin(lats) == cos(colats)
* `LS::AbstractArray{T,2}` Land see mask, on the same grid as lats and lons
* `h::AbstractArray{T,2}`` orography, array on the same grid as lats and lons
* `R1i::T` square inverse of Rossby radius 1 200-500hPa, default 1/(700km)^2
* `R2i::T` square inverse of Rossby radius 2 500-800hPa, default 1/(450km)^2
* `H0::T` scaling parameter for topography, default 9000m
* `τRi::T` inverse of radiative time scale, default 1/(25d)
* `τEi::T` inverse of drag time scale, default 1/(3d)
* `cH::T` horizonatal diffusion coefficient
* `α1::T` drag coefficient 1, default 0.5
* `α2::T` drag coefficient 2, default 0.5
* `a::T` Earth&#39;s radius  # WIP: some functions assume a=1
* `Ω::T` Earth&#39;s angular speed for Coriolis # WIP: some functions assume Ω=1/2
* `gridtype::String` either &#39;gaussian&#39; or &#39;regular&#39;, &#39;gaussian&#39; leads to all transform being done by somewhat naively implemented transforms, &#39;regular&#39; uses FastTransforms.jl
* `time_unit::T` unit so that t [normalized] = t [s] / time_unit, default = 1/4π
* `distance_unit::T`, default Earth&#39;s radius
* `ψ_unit::T`, derived from time_unit and distance_unit
* `q_unit::T`, derived from time_unit and distance_unit</code></pre><p><strong>Other constructors</strong></p><pre><code class="language-none">QG3ModelParameters(L::Int, lats::AbstractArray{T,1}, lons::AbstractArray{T,1}, LS::AbstractArray{T,2}, h::AbstractArray{T,2}, R1i::T, R2i::T, H0::T, τRi::T, τEi::T, τHi::T, α1::T, α2::T, a::T, Ω::T, gridtype::String, time_unit::T, distance_unit::T)</code></pre><p>Default arguments for most parameters, so that</p><pre><code class="language-none">QG3ModelParameters(L::Int, lats::AbstractArray{T,1}, lons::AbstractArray{T,1}, LS::AbstractArray{T,2}, h::AbstractArray{T,2})</code></pre><p>works as well.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.EK-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T}}} where T&lt;:Number" href="#QG3.EK-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T}}} where T&lt;:Number"><code>QG3.EK</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Ekman dissipation</p><p>EK = ∇(k∇ψ) = (∇k ∇ψ) + k Δψ  EK = 1/a^2cos^2ϕ ∂k/∂λ ∂ψ/∂λ + 1/a^2 ∂k/∂ϕ ∂ψ/∂ϕ + k Δψ   (a==1)</p><p>m.∂k∂λ  includes 1/cos^2ϕ</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.EK3_simple-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T}}} where T&lt;:Number" href="#QG3.EK3_simple-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, QG3Model{T}}} where T&lt;:Number"><code>QG3.EK3_simple</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Simplified Ekman dissipiation for k(ϕ,λ) = const</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.H-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, QG3Model{T}}} where T&lt;:Number" href="#QG3.H-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Int64, QG3Model{T}}} where T&lt;:Number"><code>QG3.H</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Horizontal diffusion, q&#39; is anomolous pv (without coriolis)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.J-Tuple{Any, Any, QG3Model}" href="#QG3.J-Tuple{Any, Any, QG3Model}"><code>QG3.J</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the Jacobian determinant from ψ and q in μ,λ coordinates, J = ∂ψ/∂x ∂q/∂y - ∂ψ/∂y ∂q/∂x = 1/a^2cosϕ ( - ∂ψ/∂λ ∂q/∂ϕ + ∂ψ/∂ϕ ∂q/∂λ) =  1/a^2 (- ∂ψ/∂λ ∂q/∂μ + ∂ψ/∂μ ∂q/∂λ)</p><p>The last term ∂ψ/∂λ accounts for the planetery vorticity, actually it is 2Ω ∂ψ/∂λ, but 2Ω == 1, (write q = q&#39; + 2Ωμ to proof it)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.J3-Tuple{Any, Any, QG3Model}" href="#QG3.J3-Tuple{Any, Any, QG3Model}"><code>QG3.J3</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For the Jacobian at 850hPa, q = q&#39; + f(1+h/H<em>0) = q&#39; + f + f*h/H</em>0, so that the thrid term has to be added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.J_F-Tuple{Any, Any, QG3Model}" href="#QG3.J_F-Tuple{Any, Any, QG3Model}"><code>QG3.J_F</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the Jacobian determinant from ψ and q in μ,λ coordinates without the planetary vorticity, as used in computing the eddy/transient forcing</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.QG3MM_adv-Tuple{Any, Any, Any}" href="#QG3.QG3MM_adv-Tuple{Any, Any, Any}"><code>QG3.QG3MM_adv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QG3MM_adv(q, p, t)</code></pre><p>Just the Advection</p><p>dq = - J(ψ,q)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.QG3MM_base-Tuple{Any, Any, Any}" href="#QG3.QG3MM_base-Tuple{Any, Any, Any}"><code>QG3.QG3MM_base</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QG3MM_base(q, p, t)</code></pre><p>Base model used in the MM paper, with symmetrization around the equator</p><p>dq = - J(ψ,q) - D(ψ,q) + S</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.SHtoGrid_dθ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T&lt;:Number" href="#QG3.SHtoGrid_dθ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T&lt;:Number"><code>QG3.SHtoGrid_dθ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>derivative of input after θ (azimutal angle/colatitude) in SH, uses pre computed SH evaluations (dependend on the grid type)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.SHtoGrid_dμ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T&lt;:Number" href="#QG3.SHtoGrid_dμ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T&lt;:Number"><code>QG3.SHtoGrid_dμ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>derivative of input after μ = sinϕ in SH, uses pre computed SH evaluations</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.SHtoGrid_dφ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T&lt;:Number" href="#QG3.SHtoGrid_dφ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T&lt;:Number"><code>QG3.SHtoGrid_dφ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>derivative of input after φ (polar angle) or λ (longtitude) in SH to Grid, only for a single layer</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.SHtoSH_dφ-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Integer, QG3Model{T}}} where T&lt;:Number" href="#QG3.SHtoSH_dφ-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Integer, QG3Model{T}}} where T&lt;:Number"><code>QG3.SHtoSH_dφ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>derivative of input after φ (polar angle/longtitude) in SH, output in SH</p><p>these are  variants with AbstractArray{T,3} and index i to select which layer is the input for the derivative.</p><p>there is currently a bug or at least missing feature in Zygote, the AD library, that stops views from always working flawlessly when a view is mixed with prior indexing of an array. We need a view for the derivative after φ to change the sign of m, so here is a differentiable variant of the SHtoSH_dφ function</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.SHtoSH_dφ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T&lt;:Number" href="#QG3.SHtoSH_dφ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model{T}}} where T&lt;:Number"><code>QG3.SHtoSH_dφ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>derivative of input after φ (polar angle/longtitude) in SH, output in SH</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.TR-Union{Tuple{T}, Tuple{QG3Model{T}, Any, Any, T}} where T&lt;:Number" href="#QG3.TR-Union{Tuple{T}, Tuple{QG3Model{T}, Any, Any, T}} where T&lt;:Number"><code>QG3.TR</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Temperature relaxation</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3._SHtoGrid_dμθ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{T, 3}, QG3ModelParameters, QG3.AbstractGridType{T, false}}} where T&lt;:Number" href="#QG3._SHtoGrid_dμθ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{T, 3}, QG3ModelParameters, QG3.AbstractGridType{T, false}}} where T&lt;:Number"><code>QG3._SHtoGrid_dμθ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Performs the latitude-based derivates. Uses a form of synthesis based on pre-computed values of the ass. Legendre polynomials at the grid points.</p><p>This version is optimized to be non-mutating with batched<em>vec. The inner batched</em>vec correspodends to an inverse Legendre transform and the outer multiply to an inverse Fourier transform.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.change_msign!-Tuple{Any}" href="#QG3.change_msign!-Tuple{Any}"><code>QG3.change_msign!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">change_msign(A)</code></pre><p>Change the sign of the m in SH (FastTranforms.jl convention of storing them). This version swaps the columns inplace</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.change_msign-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T&lt;:Number" href="#QG3.change_msign-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T&lt;:Number"><code>QG3.change_msign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">change_msign(A)</code></pre><p>Change the sign of the m in SH (FastTranforms.jl convention of storing them). This version returns a view</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_GaussWeights-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T&lt;:Number" href="#QG3.compute_GaussWeights-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T&lt;:Number"><code>QG3.compute_GaussWeights</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-computes gaussian weights for Legendre Transform, also checks if we really have the correct gaussian latitudes</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_P-Union{Tuple{T}, Tuple{Integer, Integer, AbstractVector{T}}} where T&lt;:Number" href="#QG3.compute_P-Union{Tuple{T}, Tuple{Integer, Integer, AbstractVector{T}}} where T&lt;:Number"><code>QG3.compute_P</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute ass. Legendre Polynomials and dP/dx (derivative of ass. Legendre Polynomial) at the grid points and also the remainder of the Spherical Harmonics at the grid points using GSL</p><p>m values are stored 0,-1,1,-2,2,-3,3,...</p><p><strong>double check -m values , so far only |m| is used, as I assume real SPH.</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_S_Roads-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, QG3Model{T}}} where T&lt;:Number" href="#QG3.compute_S_Roads-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, QG3Model{T}}} where T&lt;:Number"><code>QG3.compute_S_Roads</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute Forcing S data level,X,Y,t</p><p>Compute the forcing according to Roads, this is outlined in the MM and Corti paper as well.</p><p>This uses an unfiltered version, in the Corti paper there is a filter. Maybe implement it as well</p><ul><li>data, input data</li><li>m, QG3Model Parameters and pre-computed fields</li><li>kwargs<ul><li>datasource, either &#39;qprime&#39; (anomalous potential vorticity) or &#39;sf&#39; (streamfunction)</li></ul></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_S_t_corti" href="#QG3.compute_S_t_corti"><code>QG3.compute_S_t_corti</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Pre-compute time-dependent Forcing S data level,X,Y,t</p><p>Like in the Corti paper for the seasonal run this interpolates between two extremal forcings.</p><ul><li>Nt_year: how many days does a year have / period length of the sinus</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_TR-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number" href="#QG3.compute_TR-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number"><code>QG3.compute_TR</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute array of temperature relaxation coefficients.</p><p>(l=0, m=0)-coefficient is assigned zero. This results in this expansion coefficient beeing constant in the whole model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_acosϕi-Tuple{QG3ModelParameters}" href="#QG3.compute_acosϕi-Tuple{QG3ModelParameters}"><code>QG3.compute_acosϕi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute (a*cos(ϕ))^-1 (latitude matrix)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_batched_ψq_transform_matrices-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T&lt;:Number" href="#QG3.compute_batched_ψq_transform_matrices-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T&lt;:Number"><code>QG3.compute_batched_ψq_transform_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_batched_ψq_transform_matrices</code></pre><p>prepares the transform from q to ψ and back for a batched matrix vector multiply, see also (@ref)[<code>compute_ψq_transform_matrices</code>]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_coriolis_vector_SH-Tuple{QG3ModelParameters, Any, Any, Any}" href="#QG3.compute_coriolis_vector_SH-Tuple{QG3ModelParameters, Any, Any, Any}"><code>QG3.compute_coriolis_vector_SH</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute a matrix with with the Coriolis factor</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_cosϕ-Tuple{QG3ModelParameters}" href="#QG3.compute_cosϕ-Tuple{QG3ModelParameters}"><code>QG3.compute_cosϕ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute cos(ϕ) (latitude) matrix</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_k-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number" href="#QG3.compute_k-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number"><code>QG3.compute_k</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute drag coefficient k in real grid space, double check with values from paper</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_mmMatrix-Union{Tuple{T}, Tuple{Integer, Integer}} where T&lt;:Number" href="#QG3.compute_mmMatrix-Union{Tuple{T}, Tuple{Integer, Integer}} where T&lt;:Number"><code>QG3.compute_mmMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute a matrix with (m) values of the SH matrix format of FastTransforms.jl, used for zonal derivative</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_Δ-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number" href="#QG3.compute_Δ-Union{Tuple{QG3ModelParameters{T}}, Tuple{T}} where T&lt;:Number"><code>QG3.compute_Δ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute the Laplacian in Spherical Harmonics, follows the matrix convention of FastTransforms.jl</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_ψq_transform_matrices-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T&lt;:Number" href="#QG3.compute_ψq_transform_matrices-Union{Tuple{T}, Tuple{QG3ModelParameters{T}, Any}} where T&lt;:Number"><code>QG3.compute_ψq_transform_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pre-compute matrices involved in transforming vorticity to streamfunction and back</p><p>q = Tψq * ψ + f ψ = Tqψ * (q - f) = Tψq^(-1) * (q - f)</p><p><strong>For l=0 the matrix is singular. In the fortran code they set q to something which for me does not make sense. Here Tψq(l=0) is just 1, so that transforming back and forth recovers the correct ψ. This makes sense in my eyes because q is only ever used for its spatial derivatives, all of which are 0 for l=0.</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.compute_∇8-Tuple{QG3ModelParameters}" href="#QG3.compute_∇8-Tuple{QG3ModelParameters}"><code>QG3.compute_∇8</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot; Pre-compute the 8-th derivative in Spherical Harmonics</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.lMatrix-Tuple{Any, Any}" href="#QG3.lMatrix-Tuple{Any, Any}"><code>QG3.lMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return l-Matrix of SH coefficients in convention of FastTransforms.jl</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.level_index-Tuple{Any, Any}" href="#QG3.level_index-Tuple{Any, Any}"><code>QG3.level_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">level_index(strings,lvls)</code></pre><p>Helper function for indexing netcdf files with many levels.</p><ul><li>string, array with name of levels to be selected</li><li>lvls, array with all levels</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.qprimetoψ-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number" href="#QG3.qprimetoψ-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number"><code>QG3.qprimetoψ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert the anomalous potential vorticity q&#39; to streamfunction ψ</p><p>This version is slightly slower than the old one (as it not aware of the matrix being half full of zeroes), but it is non-mutating which makes it suitable for the automatic differentation.</p><p>It replaces the double loop over the coefficient matrix with a batched vector multiply. The advantage of that is that it is optimised for GPU, so it might actually be faster on the GPU than doing a manual loop.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.qtoψ-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number" href="#QG3.qtoψ-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number"><code>QG3.qtoψ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert the potential vorticity q to streamfunction ψ</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.sph_zero_spurious_modes!-Tuple{AbstractMatrix{T} where T}" href="#QG3.sph_zero_spurious_modes!-Tuple{AbstractMatrix{T} where T}"><code>QG3.sph_zero_spurious_modes!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sets the unphysical numbers zero (usually only needed for FastTransforms.jl)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.transformGGridtoSH-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3ModelParameters{T}, QG3.GaussianGrid{T, false}}} where T&lt;:Number" href="#QG3.transformGGridtoSH-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3ModelParameters{T}, QG3.GaussianGrid{T, false}}} where T&lt;:Number"><code>QG3.transformGGridtoSH</code></a> — <span class="docstring-category">Method</span></header><section><div><p>manually implemented transfrom from grid to spherical space, so far only for gaussian grid</p><p>CPU variant</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.transformGGridtoSH-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3ModelParameters{T}, QG3.GaussianGrid{T, true}}} where T&lt;:Number" href="#QG3.transformGGridtoSH-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3ModelParameters{T}, QG3.GaussianGrid{T, true}}} where T&lt;:Number"><code>QG3.transformGGridtoSH</code></a> — <span class="docstring-category">Method</span></header><section><div><p>manually implemented transfrom from grid to spherical space, so far only for gaussian grid</p><p>GPU variant, r2c fft instead of r2r fft</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.transformSHtoGGrid-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3ModelParameters{T}, QG3.GaussianGrid{T, false}}} where T&lt;:Number" href="#QG3.transformSHtoGGrid-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3ModelParameters{T}, QG3.GaussianGrid{T, false}}} where T&lt;:Number"><code>QG3.transformSHtoGGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>manually implemented transform from spherical harmonics to grid. This works for all grid types, the grid type is indirectly specified through the pre-computed ass. legendre polynomials</p><p>CPU variant</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.transform_SH-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3ModelParameters{T}, QG3.GaussianGrid{T, onGPU} where onGPU}} where T&lt;:Number" href="#QG3.transform_SH-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3ModelParameters{T}, QG3.GaussianGrid{T, onGPU} where onGPU}} where T&lt;:Number"><code>QG3.transform_SH</code></a> — <span class="docstring-category">Method</span></header><section><div><p>transform_SH(data, m::QG3Model, varname::String=&quot;ψ&quot;, setzeros=true)</p><p>Transforms the data to spherical harmonics.</p><p>if setzeros == true, the &quot;unphysical&quot; lower triangle is directly set zero when using FastTransforms.jl</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.transform_grid-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model}} where T&lt;:Number" href="#QG3.transform_grid-Union{Tuple{T}, Tuple{AbstractMatrix{T}, QG3Model}} where T&lt;:Number"><code>QG3.transform_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>transform_grid(data, m::QG3Model)</p><p>Transforms the data to real space</p><p>If varname ∈ [&quot;pv&quot;,&quot;q&quot;,&quot;vorticity&quot;] the [1,1] element is set to zero first, as this element is set to the streamfunction-[1,1] usually in the ψtoq routines.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.ψtoq-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number" href="#QG3.ψtoq-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number"><code>QG3.ψtoq</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert the streamfunction ψ to the potential vorticity</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QG3.ψtoqprime-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number" href="#QG3.ψtoqprime-Union{Tuple{T}, Tuple{QG3Model{T}, AbstractArray{T, 3}}} where T&lt;:Number"><code>QG3.ψtoqprime</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert the streamfunction ψ to (anomlous) potential vorticity q&#39; in spherical harmonics basis</p><p>This version is slightly slower than the old one on CPU (as it not aware of the matrix being half full of zeroes), but it is non-mutating which makes it suitable for the automatic differentation.</p><p>It replaces the double loop over the coefficient matrix with a batched vector multiply. The advantage other besides it being non-mutating is that it is optimised for GPU, so it might actually be faster on the GPU than doing a manual loop.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 11 November 2021 17:01">Thursday 11 November 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
